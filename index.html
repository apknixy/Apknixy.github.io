<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AddMint - Ultra Professional</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        /* CSS start here (copied from style.css for all-in-one file) */

        /* General Body and Container Styles */
        body {
            font-family: 'Montserrat', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color-main); /* Using CSS variables */
            color: var(--text-color-main);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease; /* For dark/light mode */
        }

        /* Dark Mode Variables (Default) */
        body.dark-mode {
            --bg-color-main: #1a1a2e;
            --bg-color-lighter: #16213e;
            --bg-color-darker: #0d2a4a;
            --text-color-main: #e0e0e0;
            --text-color-light: #bbb;
            --text-color-accent: #00ffff;
            --border-color-main: #0f3460;
            --shadow-color-main: rgba(0, 255, 255, 0.2);
            --shadow-color-strong: rgba(0, 255, 255, 0.4);
            --highlight-color-main: #00ffff;
            --highlight-color-secondary: #ff00ff;
            --button-primary-bg: #00ffff;
            --button-primary-text: #1a1a2e;
            --button-secondary-bg: #334e68;
            --button-secondary-text: #e0e0e0;
            --input-bg: #1a1a2e;
            --input-border: #00ffff;
            --post-card-bg: #0f3460;
            --chat-bubble-left-bg: #334e68;
            --chat-bubble-right-bg: #00ffff;
            --chat-bubble-right-text: #1a1a2e;
        }

        /* Light Mode Variables (Example, not fully implemented for all elements) */
        body.light-mode {
            --bg-color-main: #f0f2f5;
            --bg-color-lighter: #ffffff;
            --bg-color-darker: #e0e0e0;
            --text-color-main: #333333;
            --text-color-light: #666666;
            --text-color-accent: #007bff;
            --border-color-main: #cccccc;
            --shadow-color-main: rgba(0, 0, 0, 0.1);
            --shadow-color-strong: rgba(0, 0, 0, 0.2);
            --highlight-color-main: #007bff;
            --highlight-color-secondary: #6f42c1;
            --button-primary-bg: #007bff;
            --button-primary-text: #ffffff;
            --button-secondary-bg: #e9ecef;
            --button-secondary-text: #333333;
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --post-card-bg: #ffffff;
            --chat-bubble-left-bg: #e9ecef;
            --chat-bubble-right-bg: #007bff;
            --chat-bubble-right-text: #ffffff;
        }


        .app-container {
            width: 100%;
            max-width: 420px; /* Typical mobile width */
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color-lighter);
            box-shadow: 0 0 30px var(--shadow-color-main); /* Subtle glow */
            border-radius: 12px;
            overflow: hidden;
            position: relative; /* For sidebar positioning */
            border: 1px solid var(--border-color-main);
        }

        /* Added by JS if necessary to initially hide until content is ready */
        .hidden {
            display: none !important; /* Forces elements to be truly hidden by default */
        }

        /* Diagnostic message - Visible only if JavaScript successfully loads and sets its display */
        #load-status {
            position:fixed; 
            top:50%; 
            left:50%; 
            transform:translate(-50%, -50%); 
            color:white; 
            background:black; 
            padding:10px; 
            z-index:9999;
            display: none; /* JS will change this to block */
            text-align: center;
        }

        /* Auth Container (Login/Signup) - Now handled more robustly by JS display flex/none */
        .auth-container {
            width: 100%;
            max-width: 420px;
            height: 100vh;
            display: flex; /* Changed from default hidden to flex, controlled by JS. */
            justify-content: center;
            align-items: center; /* Vertically centers the .auth-content */
            background-color: var(--bg-color-lighter);
            box-shadow: 0 0 30px var(--shadow-color-main);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border-color-main);
            padding: 20px;
            box-sizing: border-box;
            flex-direction: column;
            text-align: center;
        }
        .auth-content { /* Main content area for forms */
            width: 100%;
            background-color: var(--bg-color-main);
            padding: 30px 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            border: 1px solid var(--border-color-main);
            display: flex; /* Inner flex to arrange children vertically */
            flex-direction: column;
            align-items: center; /* Center login/signup forms */
        }
        .app-logo-splash { /* Used by auth-content h1 */
            width: 100px;
            height: 100px;
            background: linear-gradient(45deg, #00ffff, #ff00ff); 
            border-radius: 50%;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.4);
            animation: pulse 2s infinite alternate;
        }
        .app-logo-splash::before {
            content: 'A'; 
            font-family: 'Montserrat', sans-serif;
            font-size: 60px;
            font-weight: bold;
            color: #1a1a2e;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }


        .auth-screen { 
            display: none; /* Default to hidden */
            width: 100%; 
            flex-direction: column; 
            align-items: center; 
        }
        .auth-screen.active {
            display: flex; /* Active screen becomes visible flex */
        }
        .auth-text { 
            font-size: 0.9em;
            margin-top: 15px;
            color: var(--text-color-light);
        }
        .auth-text a { 
            color: var(--highlight-color-main);
            text-decoration: none;
            font-weight: bold;
        }
        .auth-text a:hover {
            text-decoration: underline;
        }
        .status-message { 
            margin-top: 15px;
            padding: 8px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .status-message.error { 
            background-color: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }
        .status-message.success { 
            background-color: rgba(51, 255, 87, 0.2);
            color: #33ff57;
            border: 1px solid #33ff57;
        }
        .status-message.info { 
            background-color: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            border: 1px solid #00ffff;
        }


        /* Header */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: var(--border-color-main);
            color: white;
            border-bottom: 1px solid var(--bg-color-darker);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .header-left, .header-right {
            display: flex;
            align-items: center;
        }

        .app-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-left: 15px;
            color: var(--highlight-color-main);
            text-shadow: 0 0 5px var(--highlight-color-main);
        }

        .icon-button {
            background: none;
            border: none;
            color: white;
            font-size: 1.2em;
            cursor: pointer;
            margin-left: 15px;
            transition: color 0.3s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            color: var(--highlight-color-main);
            transform: scale(1.1);
        }

        .loader { 
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--highlight-color-main);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }

        .menu-icon {
            width: 30px;
            height: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
        }

        .menu-icon .bar {
            width: 100%;
            height: 3px;
            background-color: white;
            border-radius: 2px;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            top: 0;
            left: -300px; /* Hidden by default */
            width: 280px;
            height: 100%;
            background-color: var(--border-color-main);
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.5);
            z-index: 20;
            transition: left 0.3s ease-in-out;
            padding-top: 20px;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--bg-color-darker);
            margin-bottom: 20px;
            position: relative;
        }

        .sidebar-header h3 {
            margin: 0 0 0 15px;
            color: var(--highlight-color-main);
            font-size: 1.4em;
            max-width: 150px; /* Prevent long names from pushing close button */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sidebar-header .close-sidebar {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 2em;
            color: white;
            cursor: pointer;
            line-height: 1;
        }

        .profile-avatar-small {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--highlight-color-main); /* Default for coded avatars */
            overflow: hidden;
            position: relative;
            border: 2px solid var(--highlight-color-main);
            flex-shrink: 0;
            background-size: cover; /* For direct pic link */
            background-position: center; /* For direct pic link */
        }
        .profile-avatar-small::before {
            content: '👤'; /* Default large avatar */
            font-family: 'Font Awesome 6 Free'; font-weight: 900;
            font-size: 30px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--button-primary-text);
        }
        .profile-avatar-small[style*="background-image"]::before {
            content: none; /* Hide default emoji if image is loaded */
        }


        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar ul li {
            margin-bottom: 10px;
        }

        .sidebar ul li a {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: var(--text-color-main);
            text-decoration: none;
            font-size: 1.1em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .sidebar ul li a:hover {
            background-color: var(--bg-color-main);
            color: var(--highlight-color-main);
        }

        /* Data Saver Toggle */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-left: auto; /* Push to the right */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch label {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-switch label:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + label {
            background-color: var(--highlight-color-main);
        }

        .toggle-switch input:checked + label:before {
            -webkit-transform: translateX(20px);
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }


        /* Main Content */
        .main-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 80px; /* Space for bottom nav */
        }

        .app-screen {
            display: none;
        }

        .app-screen.active {
            display: block;
        }

        section {
            background-color: var(--bg-color-main);
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px var(--shadow-color-main);
            border: 1px solid var(--border-color-main);
        }

        h2 {
            color: var(--highlight-color-main);
            text-shadow: 0 0 5px var(--highlight-color-main);
            border-bottom: 2px solid var(--border-color-main);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        /* Category Filter */
        .category-filter {
            margin-bottom: 20px;
        }
        .category-filter select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            background-color: var(--input-bg);
            color: var(--text-color-main);
            border: 1px solid var(--input-border);
        }


        /* Post Feed Styles */
        .posts-feed {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between posts */
        }

        .post-card {
            background-color: var(--post-card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.08);
            border: 1px solid var(--bg-color-darker);
            transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
            position: relative; /* For neon effect */
        }

        .post-card.neon-glow {
            box-shadow: 0 0 5px var(--highlight-color-main), 0 0 15px var(--highlight-color-main), 0 0 25px var(--highlight-color-main), 0 0 35px var(--highlight-color-main);
            border-color: var(--highlight-color-main);
        }
        
        /* NEW: Remix effect */
        .post-card.remixed {
            background-color: #2a163e; /* Lighter purple/darker blue for remixed */
            border-color: #ff00ff; /* Pink border */
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.2);
        }
        .remix-content-wrapper {
            display: flex;
            flex-direction: column; /* Stack them for better mobile view */
            gap: 10px;
            margin-top: 10px;
            border-top: 1px dashed #0d2a4a;
            padding-top: 15px;
        }
        .remix-original, .remix-reply {
            padding: 10px;
            border-radius: 8px;
            background-color: #1a1a2e; /* Darker background for remix sections */
            border: 1px solid #0f3460;
        }
        .remix-original h5, .remix-reply h5 {
            margin-top: 0;
            color: #00ffff;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .remix-original p, .remix-reply p {
            font-size: 0.9em;
            color: #e0e0e0;
            margin-bottom: 0;
        }
        /* End NEW: Remix effect */


        .post-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #00ffff; /* Default for coded avatars */
            margin-right: 10px;
            overflow: hidden;
            position: relative;
            border: 2px solid #00ffff;
            flex-shrink: 0;
            cursor: pointer; /* Make avatar clickable */
        }

        /* Styles for coded avatars - All 50 logos */
        /* These styles will be dynamically generated by JS, example below */
        /* .profile-avatar.user-logo-1 { background-color: #ff6347; } .profile-avatar.user-logo-1::before { content: '🧑'; font-size: 24px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } */
        /* JS function applies these in a style tag directly to head */
        
        .profile-avatar.user-logo-default::before {
            content: '👤';
            font-family: 'Font Awesome 6 Free'; 
            font-weight: 900;
            font-size: 24px;
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #1a1a2e;
        }

        .profile-avatar[style*="background-image"]::before {
            content: none !important; /* Hide default emoji if direct image URL is set */
        }
        

        .profile-avatar.small {
            width: 30px;
            height: 30px;
            border-width: 1px;
        }

        .username {
            font-weight: bold;
            color: #fff;
            flex-grow: 1;
            cursor: pointer; /* Make username clickable */
        }

        .post-options {
            position: relative;
        }

        .post-options .fa-ellipsis-v {
            cursor: pointer;
            font-size: 1.2em;
            color: #888;
        }

        .options-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background-color: #1a1a2e;
            border: 1px solid #0f3460;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            z-index: 5;
            min-width: 120px;
            overflow: hidden;
        }

        .options-dropdown span {
            display: block;
            padding: 10px 15px;
            cursor: pointer;
            color: #e0e0e0;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .options-dropdown span:hover {
            background-color: #0f3460;
            color: #00ffff;
        }

        .post-content {
            margin-bottom: 10px;
        }

        .post-content p {
            margin: 0 0 10px 0;
        }

        .post-content img {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid #0d2a4a;
        }

        .post-content a {
            color: #00ffff;
            text-decoration: underline;
            word-break: break-all;
        }

        .post-footer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .post-actions {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .like-button, .views-count, .translate-button, .speak-button {
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #bbb;
            transition: color 0.2s ease;
        }

        .like-button i, .views-count i, .translate-button i, .speak-button i {
            margin-right: 5px;
        }

        .like-button .fas.fa-heart {
            color: #ff007f; /* Red for liked */
            animation: bounceIn 0.3s ease-out;
        }
        .speak-button.active i {
            color: #00ffff; /* Highlight when speaking */
        }


        .post-reactions {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
            color: #aaa;
        }

        .emoji-reaction-display {
            display: flex;
            gap: 5px;
            flex-wrap: wrap; /* Allow wrapping if many emojis */
        }

        .emoji-reaction-display .emoji {
            font-size: 1.2em;
            display: flex; /* To align count */
            align-items: center;
        }

        .emoji-reaction-display .count {
            font-size: 0.8em;
            margin-left: 2px;
            color: #e0e0e0;
        }

        .total-reactions {
            margin-left: 10px;
            font-weight: bold;
            color: #00ffff;
        }

        .emoji-picker, .emoji-picker-chat {
            position: absolute;
            bottom: 10px; /* Adjust based on footer position */
            left: 50%;
            transform: translateX(-50%);
            background-color: #1a1a2e;
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            gap: 10px;
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.2);
            z-index: 10;
        }

        .emoji-option {
            font-size: 1.5em;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .emoji-option:hover {
            transform: scale(1.2);
        }

        /* Horizontal Post Layout (for mixed feed) */
        .horizontal-post-container {
            display: flex;
            overflow-x: auto;
            gap: 15px;
            padding: 10px 0;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch; /* For smoother scrolling on iOS */
            margin: 10px 0;
            background-color: #0d2a4a;
            border-radius: 10px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.1);
            border: 1px solid #0f3460;
        }

        .horizontal-post-container .post-card {
            min-width: 250px; /* Fixed width for horizontal items */
            scroll-snap-align: start;
            flex-shrink: 0;
            margin-bottom: 0; /* Override default margin */
        }

        .horizontal-post-container .post-card .post-content img {
            height: 150px; /* Fixed height for horizontal images */
            object-fit: cover;
        }

        /* Table Post Layout */
        .table-post-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
            gap: 15px;
            padding: 15px;
            background-color: #0d2a4a;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.1);
            border: 1px solid #0f3460;
            margin: 10px 0;
        }

        .table-post-container .post-card {
            margin-bottom: 0; /* Override default margin */
            padding: 10px;
        }

        .table-post-container .post-card .post-content img {
            height: 100px; /* Smaller images for table layout */
            object-fit: cover;
        }
        .table-post-container .post-card .post-content p {
            font-size: 0.85em; /* Smaller text for table layout */
            display: -webkit-box;
            -webkit-line-clamp: 3; /* Limit text to 3 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        /* Form & Button Styles */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #e0e0e0;
            text-align: left;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"],
        input[type="file"],
        textarea,
        select,
        input[type="number"],
        input[type="date"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #00ffff; /* Neon border */
            border-radius: 6px;
            background-color: #1a1a2e;
            color: #e0e0e0;
            box-sizing: border-box;
            font-size: 1em;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.2);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        input[type="password"]:focus,
        textarea:focus,
        select:focus,
        input[type="number"]:focus,
        input[type="date"]:focus {
            border-color: #ff00ff; /* Pink focus */
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
            outline: none;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        input[type="file"] {
            padding: 8px; /* Less padding for file input */
        }

        .btn {
            display: inline-block;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            text-align: center;
            text-decoration: none; /* For link buttons */
        }

        .btn.primary-btn {
            background-color: #00ffff;
            color: #1a1a2e;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }

        .btn.primary-btn:hover {
            background-color: #00e0e0;
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }
        .btn:disabled { /* General styling for disabled buttons */
            opacity: 0.6;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }


        .btn.secondary-btn {
            background-color: #334e68;
            color: #e0e0e0;
            border: 1px solid #00ffff;
        }

        .btn.secondary-btn:hover {
            background-color: #4a6684;
            transform: translateY(-2px);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }

        .btn.danger-btn {
            background-color: #e74c3c;
            color: white;
        }

        .btn.danger-btn:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }

        .btn.social-btn {
            background-color: #2e8b57; /* WhatsApp Green */
            color: white;
            margin-right: 10px;
        }

        .btn.social-btn i {
            margin-right: 8px;
        }

        .btn.social-btn:hover {
            background-color: #226b41;
        }

        .profile-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #1a1a2e;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.3);
            border: 1px solid #00ffff;
            width: 90%;
            max-width: 500px;
            position: relative;
            animation: fadeInScale 0.3s ease-out;
            max-height: 90vh; /* Allow scrolling for tall modals */
            overflow-y: auto;
        }

        .modal-content h3 {
            color: #00ffff;
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .modal-content .btn {
            margin-top: 15px;
            width: 100%;
        }

        .logo-options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #0f3460;
            border-radius: 8px;
            background-color: #0d2a4a;
        }

        .logo-option-item {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #333; /* Base color for logo previews */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid transparent;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .logo-option-item.selected {
            border-color: #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        .logo-option-item:hover {
            transform: scale(1.1);
        }

        /* Specific profile avatar styles for edit profile */
        .profile-avatar-large.user-logo-1 { background-color: #ff6347; } .profile-avatar-large.user-logo-1::before { content: '🧑'; font-size: 60px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #1a1a2e; }
        .profile-avatar-large.user-logo-2 { background-color: #6a5acd; } .profile-avatar-large.user-logo-2::before { content: '👩'; font-size: 60px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #1a1a2e; }
        /* Add other 48 logos dynamically or pre-define here if preferred */
        /* ... (rest of 50 logo styles would be here) */
        .profile-avatar.user-logo-default::before { /* Default fallback if dynamic styles fail */
            content: '👤';
            font-family: 'Font Awesome 6 Free'; 
            font-weight: 900;
            font-size: 24px;
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #1a1a2e;
        }

        /* Profile Screen Specifics */
        .profile-header-area {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #0f3460;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            border: 1px solid #0d2a4a;
        }

        .profile-avatar-large {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #00ffff; /* Default for coded avatars */
            margin: 0 auto 20px auto;
            overflow: hidden;
            position: relative;
            border: 4px solid #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            background-size: cover;
            background-position: center;
        }
        /* Override default avatar emoji if background image is present */
        .profile-avatar-large[style*="background-image"]::before {
            content: none !important; 
        }

        .profile-name, .profile-bio {
            color: #e0e0e0;
            font-size: 0.95em;
            margin-bottom: 5px;
        }
        .profile-stats {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 15px;
            font-size: 1.1em;
        }

        .profile-stats div {
            text-align: center;
            padding: 8px 12px;
            background-color: #1a1a2e;
            border-radius: 8px;
            border: 1px solid #00ffff;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.2);
        }

        .profile-stats span {
            display: block;
            font-weight: bold;
            font-size: 1.2em;
            color: #00ffff;
        }

        .clickable-stat {
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .clickable-stat:hover {
            background-color: #0d2a4a;
            transform: translateY(-2px);
        }

        /* Chat Styles */
        .message-list-container, .chat-window-container {
            background-color: #0f3460;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            border: 1px solid #0d2a4a;
            height: calc(100% - 40px);
            display: flex;
            flex-direction: column;
        }

        .recent-chats-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        .chat-item {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            border-bottom: 1px solid #1a1a2e;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .chat-item:hover {
            background-color: #1a1a2e;
        }

        .chat-info {
            margin-left: 10px;
            flex-grow: 1;
        }

        .chat-username {
            font-weight: bold;
            color: #00ffff;
            display: block;
        }

        .last-message {
            font-size: 0.9em;
            color: #bbb;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-window-container {
            height: calc(100vh - 160px);
            padding: 0;
        }

        .chat-header {
            display: flex;
            align-items: center;
            padding: 15px;
            background-color: #0f3460;
            border-bottom: 1px solid #0d2a4a;
            color: white;
        }

        .chat-header .icon-button {
            margin-right: 10px;
        }

        #chat-partner-username {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff;
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background-color: #1a1a2e;
        }

        .message-bubble {
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.4;
            position: relative;
        }

        .message-bubble.right {
            align-self: flex-end;
            background-color: #00ffff;
            color: #1a1a2e;
            border-bottom-right-radius: 4px;
        }

        .message-bubble.left {
            align-self: flex-start;
            background-color: #334e68;
            color: #e0e0e0;
            border-bottom-left-radius: 4px;
        }

        .chat-input-area {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid #0d2a4a;
            background-color: #0f3460;
        }

        #message-input {
            flex-grow: 1;
            margin-right: 10px;
            min-height: 40px;
            max-height: 100px;
            resize: none;
            align-self: center;
        }

        #send-message-btn {
            padding: 10px 15px;
            font-size: 1.2em;
        }

        /* Search Screen */
        .search-input-group {
            display: flex;
            margin-bottom: 20px;
        }

        #search-query {
            flex-grow: 1;
            margin-right: 10px;
        }

        .search-results-container h3 {
            margin-top: 25px;
            color: #00ffff;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 5px;
        }

        .search-list {
            list-style: none;
            padding: 0;
            margin: 0;
            background-color: #0d2a4a;
            border-radius: 8px;
            border: 1px solid #0f3460;
            max-height: 300px;
            overflow-y: auto;
        }

        .search-user-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #1a1a2e;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .search-user-item:last-child {
            border-bottom: none;
        }

        .search-user-item:hover {
            background-color: #1a1a2e;
        }

        .search-username {
            flex-grow: 1;
            margin-left: 10px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .search-user-item .follow-btn {
            padding: 5px 10px;
            font-size: 0.9em;
        }

        /* NEW: Monetization Screen Styles */
        #monetization-screen .info-card {
            background-color: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #0d2a4a;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.08);
        }
        #monetization-screen .info-card h4 {
            color: #00ffff;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        #monetization-screen .info-card i {
            margin-right: 8px;
            color: #ff00ff;
        }
        #monetization-screen .info-card .btn {
            margin-top: 10px;
            width: auto;
            display: inline-block;
            margin-right: 10px;
        }


        /* Bottom Navigation */
        .app-bottom-nav {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #0f3460;
            border-top: 1px solid #0d2a4a;
            padding: 10px 0;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            bottom: 0;
            width: 100%;
            z-index: 10;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: #888;
            font-size: 0.8em;
            transition: color 0.3s ease, transform 0.2s ease;
        }

        .nav-item .icon-wrapper {
            width: 30px;
            height: 30px;
            margin-bottom: 5px;
            position: relative;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid transparent; /* For active state glow */
            transition: border-color 0.3s ease;
        }

        /* Custom Coded Icons for Bottom Nav */
        .home-icon::before { content: '\f015'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: #e0e0e0; }
        .search-icon::before { content: '\f002'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: #e0e0e0; }
        .upload-icon::before { content: '\f067'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: #e0e0e0; } /* Plus Circle */
        .messages-icon::before { content: '\f075'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: #e0e0e0; } /* Comment Dots */
        .profile-icon::before { content: '\f406'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: #e0e0e0; } /* User Circle Solid */

        .nav-item.active {
            color: #00ffff;
            transform: translateY(-3px);
        }

        .nav-item.active .icon-wrapper {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .nav-item.active .icon-wrapper::before {
            color: #00ffff;
        }


        /* Ad Modal */
        #ad-modal .modal-content {
            text-align: center;
        }
        #ad-placeholder {
            background-color: #0d2a4a;
            height: 150px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            border-radius: 8px;
            font-style: italic;
            color: #bbb;
            border: 1px dashed #00ffff;
        }
        #close-ad-modal {
            margin-top: 20px;
        }

        /* Reward Popup */
        .reward-content {
            text-align: center;
        }
        .reward-content h3 {
            color: #33ff57; /* Green for success */
            text-shadow: 0 0 8px rgba(51, 255, 87, 0.6);
            margin-bottom: 15px;
        }
        .reward-content i.fas.fa-trophy {
            font-size: 1.5em;
            margin-left: 10px;
            vertical-align: middle;
        }
        #reward-message {
            font-size: 1.1em;
            color: #e0e0e0;
            margin-bottom: 20px;
        }

        /* Toast Notification */
        .toast-notification {
            position: fixed;
            bottom: 80px; /* Above bottom nav */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            font-size: 0.95em;
            min-width: 200px;
            text-align: center;
        }

        .toast-notification.show {
            opacity: 1;
            visibility: visible;
        }
        .toast-notification.error { background-color: #e74c3c; }
        .toast-notification.success { background-color: #27ae60; }
        .toast-notification.info { background-color: #3498db; }


        /* NEW: Language Selection Modal */
        #language-select-modal .language-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #0f3460;
            border-radius: 8px;
            background-color: #0d2a4a;
        }
        #language-select-modal .language-option {
            padding: 10px;
            border-radius: 6px;
            background-color: #1a1a2e;
            border: 1px solid #00ffff;
            color: #e0e0e0;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        #language-select-modal .language-option.selected {
            background-color: #00ffff;
            color: #1a1a2e;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }
        #language-select-modal .language-option:hover {
            transform: translateY(-2px);
        }

        /* Animation for shake effect on remix */
        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }


        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 255, 0.6), 0 0 20px rgba(255, 0, 255, 0.4); }
            100% { transform: scale(1.05); box-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 30px rgba(255, 0, 255, 0.6); }
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .app-container, .auth-screen-wrapper {
                border-radius: 0;
                box-shadow: none;
                max-width: 100%;
                height: 100vh; /* Ensure it takes full height on small screens */
            }

            body {
                align-items: flex-start; /* Align to top on small screens */
            }

            .main-content {
                padding: 10px;
            }

            .app-header {
                padding: 10px;
            }

            .app-title {
                font-size: 1.3em;
                margin-left: 10px;
            }

            .status-display {
                font-size: 0.8em;
                padding: 3px 8px;
            }

            .icon-button {
                font-size: 1em;
                margin-left: 10px;
            }

            .app-bottom-nav {
                padding: 8px 0;
            }

            .nav-item {
                font-size: 0.7em;
            }

            .nav-item .icon-wrapper {
                width: 25px;
                height: 25px;
            }

            .home-icon::before, .search-icon::before, .upload-icon::before, .messages-icon::before, .profile-icon::before {
                font-size: 1.2em;
            }

            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .profile-avatar-large {
                width: 80px;
                height: 80px;
            }

            .profile-avatar-large::before {
                font-size: 45px;
            }

            .profile-stats {
                gap: 15px;
                font-size: 1em;
            }

            .profile-stats span {
                font-size: 1.1em;
            }

            .btn {
                padding: 10px 15px;
                font-size: 1em;
            }

            .profile-actions {
                flex-direction: column;
                align-items: center;
            }
            .profile-actions .btn {
                width: 80%;
            }

            .emoji-picker, .emoji-picker-chat {
                padding: 6px;
                gap: 8px;
            }

            .emoji-option {
                font-size: 1.3em;
            }

            .message-bubble {
                max-width: 90%;
            }

            .toast-notification {
                bottom: 70px;
                font-size: 0.8em;
                min-width: unset;
                width: auto;
                padding: 10px 15px;
            }

            .auth-content {
                padding: 20px 15px;
            }
        }
    </style>
</head>
<body class="dark-mode"> 
    
    <!-- This paragraph is for JavaScript load testing. It should be the ONLY thing initially visible IF JS loads. -->
    <p id="load-status">Loading Application...</p>

    <!-- Auth Container for Login/Register (Hidden by default, JS will manage display) -->
    <div id="auth-container" class="auth-container hidden">
        <div class="auth-content">
            <div class="app-logo-splash auth-logo"></div> <h1>AddMint</h1>
            <section id="login-screen" class="auth-screen active">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="login-email">Email:</label>
                    <input type="email" id="login-email" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="login-password">Password:</label>
                    <div class="password-input-group">
                        <input type="password" id="login-password" placeholder="Enter your password">
                        <span class="password-toggle" data-target="login-password"><i class="fas fa-eye"></i></span>
                    </div>
                </div>
                <button class="btn primary-btn" id="login-btn">Login</button>
                <p class="auth-text">
                    <a href="#" id="forgot-password-link">Forgot Password?</a>
                </p>
                <p class="auth-text">Don't have an account? <a href="#" id="show-signup">Register</a></p>
                <p id="login-status" class="status-message"></p>
            </section>

            <section id="signup-screen" class="auth-screen hidden">
                <h2>Register</h2>
                <div class="form-group">
                    <label for="signup-email">Email:</label>
                    <input type="email" id="signup-email" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="signup-password">Password:</label>
                    <div class="password-input-group">
                        <input type="password" id="signup-password" placeholder="Create a password">
                        <span class="password-toggle" data-target="signup-password"><i class="fas fa-eye"></i></span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="signup-confirm-password">Confirm Password:</label>
                    <div class="password-input-group">
                        <input type="password" id="signup-confirm-password" placeholder="Confirm your password">
                        <span class="password-toggle" data-target="signup-confirm-password"><i class="fas fa-eye"></i></span>
                    </div>
                </div>
                <button class="btn primary-btn" id="signup-btn">Register</button>
                <p class="auth-text">Already have an account? <a href="#" id="show-login">Login</a></p>
                <p id="signup-status" class="status-message"></p>
            </section>
        </div>
    </div>


    <div id="forgot-password-modal" class="modal hidden">
        <div class="modal-content">
            <h3>Reset Password</h3>
            <p>Enter your email address to receive a password reset link.</p>
            <div class="form-group">
                <label for="reset-email">Email:</label>
                <input type="email" id="reset-email" placeholder="Your email address">
            </div>
            <button class="btn primary-btn" id="send-reset-email-btn">Send Reset Link</button>
            <p id="reset-status" class="status-message"></p>
            <button class="btn secondary-btn" id="close-reset-modal">Cancel</button>
        </div>
    </div>


    <!-- Main Application Container (Hidden by default, JS will manage display) -->
    <div id="app-container" class="app-container hidden">

        <header class="app-header">
            <div class="header-left">
                <div class="menu-icon" id="menu-toggle">
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                </div>
                <div class="app-title">AddMint</div>
            </div>
            <div class="header-center">
                <div class="status-display">
                    <span id="header-coins" class="clickable-stat" data-resource-type="coins">0 C</span> |
                    <span id="header-credits" class="clickable-stat" data-resource-type="credits">0 Cr</span> |
                    <span id="header-limit" class="clickable-stat" data-resource-type="limit">0 L</span> |
                    <span id="header-mint" class="clickable-stat" data-resource-type="mint">0 M</span>
                </div>
            </div>
            <div class="header-right">
                <div class="icon-button" id="refresh-posts-btn" title="Refresh Feed">
                    <i class="fas fa-sync-alt"></i>
                </div>
                <div class="icon-button" id="gift-claim-btn" title="Claim Daily Reward">
                    <i class="fas fa-gift"></i>
                </div>
            </div>
        </header>

        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <div class="profile-avatar-small" id="sidebar-profile-avatar"></div>
                <h3 id="sidebar-username">My User</h3> 
                <div class="close-sidebar" id="close-sidebar">&times;</div>
            </div>
            <ul>
                <li><a href="#" data-screen="home"><i class="fas fa-home"></i> Home Feed</a></li>
                <li><a href="#" data-screen="feed"><i class="fas fa-stream"></i> Immersive Feed</a></li>
                <li><a href="#" data-screen="profile"><i class="fas fa-user-circle"></i> My Profile</a></li>
                <li><a href="#" data-screen="upload"><i class="fas fa-plus-circle"></i> Upload Post</a></li>
                <li><a href="#" data-screen="messages"><i class="fas fa-comments"></i> Messages</a></li>
                <li><a href="#" data-screen="search"><i class="fas fa-search"></i> Search Users</a></li>
                <li><a href="#" data-screen="monetization"><i class="fas fa-dollar-sign"></i> Earn & Boost</a></li>
                <li><a href="#" id="data-saver-toggle"><i class="fas fa-wifi"></i> Data Saver <span class="toggle-switch"><input type="checkbox" id="data-saver-checkbox"><label for="data-saver-checkbox"></label></span></a></li>
                <li><a href="#" id="dark-mode-toggle"><i class="fas fa-moon"></i> Dark Mode <span class="toggle-switch"><input type="checkbox" id="dark-mode-checkbox" checked><label for="dark-mode-checkbox"></label></span></a></li>
                <li><a href="https://www.instagram.com/addmint__" target="_blank"><i class="fab fa-instagram"></i> Our Instagram</a></li>
                <li><a href="https://www.youtube.com/@add_mintmint" target="_blank"><i class="fab fa-youtube"></i> Our YouTube</a></li>
                <li><a href="#" data-screen="about"><i class="fas fa-info-circle"></i> About Us</a></li>
                <li><a href="#" data-screen="privacy"><i class="fas fa-shield-alt"></i> Privacy Policy</a></li>
                <li><a href="#" id="logout-btn"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
            </ul>
        </nav>

        <main class="main-content">
            <section id="home-screen" class="app-screen active">
                <h2>Recent Posts</h2>
                 <div class="category-filter">
                    <select id="post-category-filter">
                        <option value="all">All Categories</option>
                        <option value="Breaking News">Breaking News</option>
                        <option value="Trending News">Trending News</option>
                        <option value="Top Stories">Top Stories</option>
                        <option value="National News">National News</option>
                        <option value="International News">International News</option>
                        <option value="Politics">Politics</option>
                        <option value="Economy">Economy</option>
                        <option value="Business">Business</option>
                        <option value="Finance">Finance</option>
                        <option value="Stock Market">Stock Market</option>
                        <option value="Technology">Technology</option>
                        <option value="Science">Science</option>
                        <option value="Environment">Environment</option>
                        <option value="Entertainment">Entertainment</option>
                        <option value="Movies">Movies</option>
                        <option value="TV Shows">TV Shows</option>
                        <option value="Music">Music</option>
                        <option value="Celebrity Gossip">Celebrity Gossip</option>
                        <option value="Lifestyle">Lifestyle</option>
                        <option value="Fashion">Fashion</option>
                        <option value="Beauty & Grooming">Beauty & Grooming</option>
                        <option value="Food & Recipes">Food & Recipes</option>
                        <option value="Travel & Tourism">Travel & Tourism</option>
                        <option value="Sports">Sports</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Football">Football</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Olympics">Olympics</option>
                        <option value="Esports">Esports</option>
                        <option value="Health & Fitness">Health & Fitness</option>
                        <option value="Yoga & Meditation">Yoga & Meditation</option>
                        <option value="Education">Education</label>
                        <option value="Career & Jobs">Career & Jobs</option>
                        <option value="Startup & Entrepreneurship">Startup & Entrepreneurship</option>
                        <option value="Automobile">Automobile</option>
                        <option value="Real Estate">Real Estate</option>
                        <option value="Religion & Spirituality">Religion & Spirituality</option>
                        <option value="History & Culture">History & Culture</option>
                        <option value="Regional News (State-wise)">Regional News (State-wise)</option>
                        <option value="Weather Updates">Weather Updates</option>
                        <option value="Opinion & Editorials">Opinion & Editorials</option>
                        <option value="Viral & Social Media Trends">Viral & Social Media Trends</option>
                    </select>
                </div>
                <div id="posts-feed" class="posts-feed">
                    </div>
                <div id="loading-spinner" class="loader hidden"></div>
            </section>

            <section id="feed-screen" class="app-screen">
                <h2>Immersive Feed</h2>
                <div id="immersive-feed" class="immersive-feed">
                    <!-- Posts will be loaded here with snap scrolling -->
                </div>
                <div id="feed-loading-spinner" class="loader hidden"></div>
            </section>

            <section id="profile-screen" class="app-screen">
                <div id="user-profile-display">
                    <div class="profile-header-area">
                        <div class="profile-avatar-large" id="my-profile-avatar"></div>
                        <h2 id="my-profile-username">@myusername</h2>
                        <p id="my-profile-name" class="profile-name"></p>
                        <p id="my-profile-bio" class="profile-bio"></p>
                        <div class="profile-stats">
                            <div><span id="my-posts-count">0</span> Posts</div>
                            <div class="clickable-stat" data-stat="followers"><span id="my-followers-count">0</span> Followers</div>
                            <div class="clickable-stat" data-stat="following"><span id="my-following-count">0</span> Following</div>
                        </div>
                        <div class="profile-actions">
                            <button class="btn primary-btn" id="edit-profile-btn"><i class="fas fa-edit"></i> Edit Profile</button>
                            <button class="btn secondary-btn hidden" id="follow-user-btn"><i class="fas fa-user-plus"></i> Follow</button>
                            <button class="btn danger-btn hidden" id="unfollow-user-btn"><i class="fas fa-user-minus"></i> Unfollow</button>
                            <button class="btn primary-btn hidden" id="message-user-btn"><i class="fas fa-paper-plane"></i> Message</button>
                            <a href="#" id="profile-whatsapp-link" class="btn social-btn hidden" target="_blank"><i class="fab fa-whatsapp"></i> WhatsApp</a>
                            <a href="#" id="profile-instagram-link" class="btn social-btn hidden" target="_blank"><i class="fab fa-instagram"></i> Instagram</a>
                        </div>
                    </div>

                    <div id="edit-profile-modal" class="modal hidden">
                        <div class="modal-content">
                            <h3>Edit Profile</h3>
                            <p id="profile-modal-instruction" class="status-message info"></p> <!-- Status for edit modal -->
                            <div class="form-group">
                                <label for="edit-username">Username:</label>
                                <input type="text" id="edit-username" placeholder="Enter new username">
                                <span id="username-availability"></span>
                            </div>
                            <div class="form-group">
                                <label for="edit-name">Display Name:</label>
                                <input type="text" id="edit-name" placeholder="Enter your display name">
                            </div>
                            <div class="form-group">
                                <label for="edit-bio">Bio (Optional):</label>
                                <textarea id="edit-bio" placeholder="Tell us about yourself..."></textarea>
                            </div>
                            <div class="form-group">
                                <label for="edit-whatsapp">WhatsApp (Optional):</label>
                                <input type="text" id="edit-whatsapp" placeholder="e.g., +919876543210">
                            </div>
                            <div class="form-group">
                                <label for="edit-instagram">Instagram ID (Optional):</label>
                                <input type="text" id="edit-instagram" placeholder="e.g., my_insta_id">
                            </div>
                            <div class="form-group">
                                <label for="profile-pic-url-input">Direct Profile Picture URL (Optional):</label>
                                <input type="text" id="profile-pic-url-input" placeholder="e.g., https://example.com/mypic.jpg">
                                <small>Enter a direct image link (like from imgbb.com).</small>
                            </div>
                            <div class="form-group">
                                <label>Or Choose a Profile Logo:</label>
                                <div id="profile-logo-options" class="logo-options-grid">
                                    </div>
                            </div>
                            <div class="form-group">
                                <label for="account-privacy-toggle">Account Privacy:</label>
                                <div class="toggle-switch">
                                    <input type="checkbox" id="account-privacy-toggle">
                                    <label for="account-privacy-toggle"></label>
                                </div>
                                <span id="account-privacy-status">Public</span>
                            </div>
                            <p id="save-profile-status" class="status-message"></p> <!-- Status for Save Changes button -->
                            <button class="btn primary-btn" id="save-profile-btn">Save Changes</button>
                            <button class="btn secondary-btn" id="cancel-edit-profile-btn">Cancel</button>
                        </div>
                    </div>

                    <div id="follow-list-modal" class="modal hidden">
                        <div class="modal-content">
                            <h3 id="follow-list-title"></h3>
                            <div id="follow-list-content">
                                </div>
                            <button class="btn secondary-btn" id="close-follow-list-modal">Close</button>
                        </div>
                    </div>

                    <div class="profile-posts-area">
                        <h3>Posts by <span id="current-profile-username-posts">Me</span></h3>
                        <div class="profile-post-tabs">
                            <button class="btn tab-btn active" data-tab="posts">My Posts</button>
                            <button class="btn tab-btn" data-tab="reposts">My Reposts</button>
                        </div>
                        <div id="profile-posts-feed" class="posts-feed">
                            </div>
                        <div id="profile-reposts-feed" class="posts-feed hidden">
                            </div>
                    </div>
                </div>
            </section>

            <section id="upload-screen" class="app-screen">
                <h2>Upload New Post</h2>
                <div class="form-group">
                    <label for="post-category">Category:</label>
                    <select id="post-category">
                        <option value="General">General</option>
                        <option value="Breaking News">Breaking News</option>
                        <option value="Trending News">Trending News</option>
                        <option value="Top Stories">Top Stories</option>
                        <option value="National News">National News</option>
                        <option value="International News">International News</option>
                        <option value="Politics">Politics</option>
                        <option value="Economy">Economy</option>
                        <option value="Business">Business</option>
                        <option value="Finance">Finance</option>
                        <option value="Stock Market">Stock Market</option>
                        <option value="Technology">Technology</option>
                        <option value="Science">Science</option>
                        <option value="Environment">Environment</option>
                        <option value="Entertainment">Entertainment</option>
                        <option value="Movies">Movies</option>
                        <option value="TV Shows">TV Shows</option>
                        <option value="Music">Music</option>
                        <option value="Celebrity Gossip">Celebrity Gossip</option>
                        <option value="Lifestyle">Lifestyle</option>
                        <option value="Fashion">Fashion</option>
                        <option value="Beauty & Grooming">Beauty & Grooming</option>
                        <option value="Food & Recipes">Food & Recipes</option>
                        <option value="Travel & Tourism">Travel & Tourism</option>
                        <option value="Sports">Sports</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Football">Football</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Olympics">Olympics</option>
                        <option value="Esports">Esports</option>
                        <option value="Health & Fitness">Health & Fitness</option>
                        <option value="Yoga & Meditation">Yoga & Meditation</option>
                        <option value="Education">Education</label>
                        <option value="Career & Jobs">Career & Jobs</option>
                        <option value="Startup & Entrepreneurship">Startup & Entrepreneurship</option>
                        <option value="Automobile">Automobile</option>
                        <option value="Real Estate">Real Estate</option>
                        <option value="Religion & Spirituality">Religion & Spirituality</option>
                        <option value="History & Culture">History & Culture</option>
                        <option value="Regional News (State-wise)">Regional News (State-wise)</option>
                        <option value="Weather Updates">Weather Updates</option>
                        <option value="Opinion & Editorials">Opinion & Editorials</option>
                        <option value="Viral & Social Media Trends">Viral & Social Media Trends</option>
                    </select>
                </div>
                <div class="form-group rich-text-editor">
                    <label for="post-content">Post Content:</label>
                    <div class="editor-toolbar">
                        <button type="button" class="tool-btn" data-command="bold"><i class="fas fa-bold"></i></button>
                        <button type="button" class="tool-btn" data-command="italic"><i class="fas fa-italic"></i></button>
                        <button type="button" class="tool-btn" data-command="insertImage"><i class="fas fa-image"></i></button>
                        <button type="button" class="tool-btn" data-command="insertYoutube"><i class="fab fa-youtube"></i></button>
                        <button type="button" class="tool-btn" data-command="insertLink"><i class="fas fa-link"></i></button>
                    </div>
                    <textarea id="post-content" placeholder="What's on your mind? Use **bold**, *italic*, [link text](http://url.com), ![image alt](http://image.url), ![youtube video](http://youtube.com/watch?v=VIDEO_ID)"></textarea>
                    <small>Min 60, Max 10000 characters.</small>
                </div>
                <div class="form-group">
                    <label for="post-boost">Post will be active for:</label>
                    <select id="post-boost" disabled>
                        <option value="24">24 Hours (Free)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="monetize-post-checkbox">Monetize this post?</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="monetize-post-checkbox">
                        <label for="monetize-post-checkbox"></label>
                    </div>
                    <small>Earn from views on monetized posts.</small>
                </div>
                <button class="btn primary-btn" id="publish-post-btn">Publish Post</button>
                <div id="upload-status"></div>
            </section>

            <section id="messages-screen" class="app-screen">
                <h2>Messages</h2>
                <div id="message-list-container">
                    <h3>Recent Chats</h3>
                    <ul id="recent-chats-list" class="recent-chats-list">
                        </ul>
                </div>

                <div id="chat-window-container" class="chat-window-container hidden">
                    <div class="chat-header">
                        <button id="back-to-chats-btn" class="icon-button"><i class="fas fa-arrow-left"></i></button>
                        <div class="profile-avatar small" id="chat-partner-avatar"></div>
                        <span id="chat-partner-username">@ChatUser</span>
                    </div>
                    <div id="chat-messages" class="chat-messages">
                        </div>
                    <div class="chat-input-area">
                        <textarea id="message-input" placeholder="Type your message..."></textarea>
                        <button id="send-message-btn" class="btn primary-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>
                    <div class="emoji-picker-chat hidden">
                        <span class="emoji-option" data-emoji="👍">👍</span>
                        <span class="emoji-option" data-emoji="❤️">❤️</span>
                        <span class="emoji-option" data-emoji="😂">😂</span>
                        <span class="emoji-option" data-emoji="😢">😢</span>
                        <span class="emoji-option" data-emoji="🔥">🔥</span>
                    </div>
                </div>
            </section>

            <section id="search-screen" class="app-screen">
                <h2>Search Users & Posts</h2>
                <div class="search-input-group">
                    <input type="text" id="search-query" placeholder="Search by username, keyword...">
                    <button class="btn primary-btn" id="search-btn"><i class="fas fa-search"></i></button>
                </div>
                <div id="search-results" class="search-results-container">
                    <h3>Users</h3>
                    <ul id="search-user-list" class="search-list">
                        </ul>
                    <h3>Posts</h3>
                    <div id="search-post-list" class="posts-feed">
                        </div>
                    <div id="no-search-results" class="hidden">No results found.</div>
                </div>
            </section>

            <section id="earnings-screen" class="app-screen">
                <h2>My Earnings</h2>
                <div class="earnings-summary">
                    <p>Total Monetized Views: <span id="total-monetized-views">0</span></p>
                    <p>Total Unmonetized Views: <span id="total-unmonetized-views">0</span></p>
                    <p>Estimated Earnings: <span id="estimated-earnings">0.00 $</span></p>
                </div>
                <button class="btn primary-btn" id="withdraw-btn">Withdraw Earnings</button>
                <div id="withdrawal-status" class="hidden"></div>
            </section>

            <section id="about-screen" class="app-screen">
                <h2>About AddMint</h2>
                <p>AddMint is a revolutionary social media platform designed to connect people through shared interests and engaging content. We believe in fostering a positive and vibrant community where every voice can be heard.</p>
                <p>Our mission is to provide a seamless and professional experience for all users, offering unique features like dynamic post feeds, real-time messaging, and interactive user profiles.</p>
                <p>For support or inquiries, please contact us at support@addmint.com.</p>
            </section>

            <section id="privacy-screen" class="app-screen">
                <h2>Privacy Policy</h2>
                <p>Your privacy is paramount to us at AddMint. This policy outlines how we collect, use, and protect your personal information.</p>
                <h3>Information We Collect:</h3>
                <ul>
                    <li><strong>Account Information:</strong> Username, email, password (hashed).</li>
                    <li><strong>Profile Information:</strong> Optional WhatsApp number, Instagram ID, chosen profile logo.</li>
                    <li><strong>Content Data:</strong> Posts, messages, likes, reactions, views.</li>
                    <li><strong>Usage Data:</strong> Interactions with the app, features used, and technical data (e.g., device type).</li>
                </ul>
                <h3>How We Use Your Information:</h3>
                <ul>
                    <li>To provide and maintain our services.</li>
                    <li>To personalize your experience and show relevant content.</li>
                    <li>To communicate with you regarding updates, security alerts, and support.</li>
                    <li>To monitor and analyze usage patterns for service improvement.</li>
                    <li>To enforce our terms and conditions and prevent misuse.</li>
                </ul>
                <h3>Data Sharing:</h3>
                <p>We do not share your personal information with third parties except as necessary to provide our services, comply with legal obligations, or with your explicit consent.</p>
                <h3>Data Security:</h3>
                <p>We implement robust security measures, including encryption and access controls, to protect your data. However, no internet transmission is 100% secure.</p>
                <h3>Your Choices:</h3>
                <ul>
                    <li>You can update your profile information at any time.</li>
                    <li>You can delete your account by contacting support.</li>
                    <li>You can control notification preferences.</li>
                </ul>
                <p>By using AddMint, you agree to the terms of this Privacy Policy. We may update this policy periodically, and we will notify you of any significant changes.</p>
            </section>
        </main>

        <footer class="app-bottom-nav">
            <a href="#" class="nav-item active" data-screen="home">
                <div class="icon-wrapper home-icon"></div>
                <span>Home</span>
            </a>
            <a href="#" class="nav-item" data-screen="search">
                <div class="icon-wrapper search-icon"></div>
                <span>Search</span>
            </a>
            <a href="#" class="nav-item" data-screen="upload">
                <div class="icon-wrapper upload-icon"></div>
                <span>Upload</span>
            </a>
            <a href="#" class="nav-item" data-screen="messages">
                <div class="icon-wrapper messages-icon"></div>
                <span>Messages</span>
            </a>
            <a href="#" class="nav-item" data-screen="profile">
                <div class="icon-wrapper profile-icon"></div>
                <span>Profile</span>
            </a>
        </footer>

        <div id="ad-modal" class="modal hidden">
            <div class="modal-content">
                <h3>Watch an Advertisement</h3>
                <p>Please watch a short ad to claim your reward.</p>
                <div id="ad-placeholder">
                    <p>Simulating Ad (5 seconds)...</p>
                </div>
                <button class="btn secondary-btn" id="close-ad-modal" disabled>Close Ad</button>
            </div>
        </div>

        <div id="reward-popup" class="modal hidden">
            <div class="modal-content reward-content">
                <h3>Reward Claimed! <i class="fas fa-trophy"></i></h3>
                <p id="reward-message"></p>
                <button class="btn primary-btn" id="close-reward-popup">Great!</button>
            </div>
        </div>

        <div id="withdraw-modal" class="modal hidden">
            <div class="modal-content">
                <h3>Withdraw Mint</h3>
                <p><strong>Minimum withdrawal: 1,000 Mint</strong></p>
                <p>Your current Mint balance: <strong id="current-mint-balance">0 M</strong></p>
                <div class="form-group">
                    <label for="withdraw-paypal-email">PayPal Email:</label>
                    <input type="email" id="withdraw-paypal-email" placeholder="Enter your PayPal email">
                </div>
                <div class="form-group">
                    <label for="withdraw-real-name">Your Full Name:</label>
                    <input type="text" id="withdraw-real-name" placeholder="Enter your full name">
                </div>
                <div class="form-group">
                    <label for="withdraw-age">Your Age:</label>
                    <input type="number" id="withdraw-age" placeholder="Your age">
                </div>
                <div class="form-group">
                    <label for="withdraw-dob">Date of Birth:</label>
                    <input type="date" id="withdraw-dob">
                </div>
                <p style="font-size: 0.9em; color: #bbb;">Your payment will be processed within 1-15 business days.</p>
                <button class="btn primary-btn" id="confirm-withdraw-btn">Confirm Withdrawal</button>
                <button class="btn secondary-btn" id="close-withdraw-modal">Cancel</button>
                <p style="font-size: 0.8em; color: #aaa; margin-top: 15px;">Note: This process is simulated in this demo. Real withdrawals require a secure backend service.</p>
            </div>
        </div>

        <!-- Language Selection Modal for Translate -->
        <div id="language-select-modal" class="modal hidden">
            <div class="modal-content">
                <h3>Select Translation Language</h3>
                <div class="language-options">
                    <!-- Options will be dynamically added by JavaScript -->
                </div>
                <button class="btn primary-btn" id="save-language-btn">Save Language</button>
                <button class="btn secondary-btn" id="cancel-language-btn">Cancel</button>
            </div>
        </div>

        <div id="toast-notification" class="toast-notification"></div>

    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <script>
        /* JavaScript starts here (copied from script.js) */

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDlZA4grzF3fx95-11E4s7ASXwkIij1k1w",
            authDomain: "addmint-7ab6b.firebaseapp.com",
            databaseURL: "https://addmint-7ab6b-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "addmint-7ab6b",
            storageBucket: "addmint-7ab6b.firebasestorage.app",
            messagingSenderId: "504015450137",
            appId: "1:504015450137:web:694b176313582cce1e7a88",
            measurementId: "G-H7J7M23Z82"
        };

        // Initialize Firebase (add basic error handling)
        try {
            firebase.initializeApp(firebaseConfig);
            console.log("Firebase initialized successfully.");
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            const loadStatusElement = document.getElementById('load-status');
            if (loadStatusElement) {
                loadStatusElement.textContent = "Critical Error: App failed to initialize. Check console & network.";
                loadStatusElement.style.backgroundColor = "red";
            }
            // Further execution might be problematic, but try to display login
            // by setting auth_initial_check_complete = true and letting DCL fire
        }

        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        // --- DOM Elements ---
        const loadStatusElement = document.getElementById('load-status'); // Diagnostic element
        const authContainer = document.getElementById('auth-container'); // Container for login/signup screens
        const appContainer = document.getElementById('app-container'); // Main application container

        // Auth Screens Elements
        const loginScreen = document.getElementById('login-screen');
        const signupScreen = document.getElementById('signup-screen');
        const loginEmailInput = document.getElementById('login-email');
        const loginPasswordInput = document.getElementById('login-password');
        const loginBtn = document.getElementById('login-btn');
        const loginStatus = document.getElementById('login-status');
        const showSignupLink = document.getElementById('show-signup');

        const signupEmailInput = document.getElementById('signup-email');
        const signupPasswordInput = document.getElementById('signup-password');
        const signupConfirmPasswordInput = document.getElementById('signup-confirm-password');
        const signupBtn = document.getElementById('signup-btn');
        const signupStatus = document.getElementById('signup-status');
        const showLoginLink = document.getElementById('show-login');

        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const forgotPasswordModal = document.getElementById('forgot-password-modal');
        const resetEmailInput = document.getElementById('reset-email');
        const sendResetEmailBtn = document.getElementById('send-reset-email-btn');
        const resetStatus = document.getElementById('reset-status');
        const closeResetModalBtn = document.getElementById('close-reset-modal');


        const menuToggle = document.getElementById('menu-toggle');
        const sidebar = document.getElementById('sidebar');
        const closeSidebarBtn = document.getElementById('close-sidebar');
        const mainContent = document.querySelector('.main-content');
        const bottomNavItems = document.querySelectorAll('.app-bottom-nav .nav-item');
        const screenSections = document.querySelectorAll('.app-screen');
        // Coins, Credits, Limits, Gift Claim Button removed based on previous request

        const refreshPostsBtn = document.getElementById('refresh-posts-btn');
        const postsFeed = document.getElementById('posts-feed');
        const loadingSpinner = document.getElementById('loading-spinner');


        // Post Upload Screen elements
        const uploadScreen = document.getElementById('upload-screen');
        const postCategorySelect = document.getElementById('post-category');
        const postContentInput = document.getElementById('post-content');
        const postImageInput = document.getElementById('post-image'); // Keep for demo; disabled
        const postBoostSelect = document.getElementById('post-boost'); // Kept disabled for 24 hours only
        const monetizePostCheckbox = document.getElementById('monetize-post-checkbox');
        const publishPostBtn = document.getElementById('publish-post-btn');
        const uploadStatus = document.getElementById('upload-status');
        const editorToolbar = document.querySelector('.editor-toolbar');

        // Profile Screen elements
        const profileScreen = document.getElementById('profile-screen');
        const myProfileAvatar = document.getElementById('my-profile-avatar');
        const myProfileUsername = document.getElementById('my-profile-username');
        const myProfileName = document.getElementById('my-profile-name'); // Display Name
        const myProfileBio = document.getElementById('my-profile-bio'); // Bio
        const myPostsCount = document.getElementById('my-posts-count');
        const myFollowersCount = document.getElementById('my-followers-count');
        const myFollowingCount = document.getElementById('my-following-count');
        const editProfileBtn = document.getElementById('edit-profile-btn');
        const followUserBtn = document.getElementById('follow-user-btn');
        const unfollowUserBtn = document.getElementById('unfollow-user-btn');
        const messageUserBtn = document.getElementById('message-user-btn');
        const profileWhatsappLink = document.getElementById('profile-whatsapp-link');
        const profileInstagramLink = document.getElementById('profile-instagram-link');
        const currentProfileUsernamePosts = document.getElementById('current-profile-username-posts');
        const profilePostsFeed = document.getElementById('profile-posts-feed');
        const profileRepostsFeed = document.getElementById('profile-reposts-feed');
        const profilePostTabs = document.querySelectorAll('.profile-post-tabs .tab-btn'); // For profile post/repost tabs

        const editProfileModal = document.getElementById('edit-profile-modal');
        const profileModalInstruction = document.getElementById('profile-modal-instruction');
        const saveProfileStatus = document.getElementById('save-profile-status');
        const editUsernameInput = document.getElementById('edit-username');
        const usernameAvailability = document.getElementById('username-availability');
        const editNameInput = document.getElementById('edit-name');
        const editBioInput = document.getElementById('edit-bio');
        const editWhatsappInput = document.getElementById('edit-whatsapp');
        const editInstagramInput = document.getElementById('edit-instagram');
        const profilePicUrlInput = document.getElementById('profile-pic-url-input');
        const profileLogoOptions = document.getElementById('profile-logo-options');
        const accountPrivacyToggle = document.getElementById('account-privacy-toggle');
        const accountPrivacyStatus = document.getElementById('account-privacy-status');
        const saveProfileBtn = document.getElementById('save-profile-btn');
        const cancelEditProfileBtn = document.getElementById('cancel-edit-profile-btn');

        const followListModal = document.getElementById('follow-list-modal');
        const followListTitle = document.getElementById('follow-list-title');
        const followListContent = document.getElementById('follow-list-content');
        const closeFollowListModalBtn = document.getElementById('close-follow-list-modal');

        // Messaging Screen elements
        const messagesScreen = document.getElementById('messages-screen');
        const messageListContainer = document.getElementById('message-list-container');
        const recentChatsList = document.getElementById('recent-chats-list');
        const chatWindowContainer = document.getElementById('chat-window-container');
        const chatPartnerUsername = document.getElementById('chat-partner-username');
        const chatPartnerAvatar = document.getElementById('chat-partner-avatar'); // Chat partner's avatar element
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const backToChatsBtn = document.getElementById('back-to-chats-btn');

        // Search Screen elements
        const searchScreen = document.getElementById('search-screen');
        const searchQueryInput = document.getElementById('search-query');
        const searchBtn = document.getElementById('search-btn');
        const searchUserList = document.getElementById('search-user-list');
        const searchPostList = document.getElementById('search-post-list');
        const noSearchResults = document.getElementById('no-search-results');

        // Earnings Screen elements
        const earningsScreen = document.getElementById('earnings-screen');
        const totalMonetizedViewsSpan = document.getElementById('total-monetized-views');
        const totalUnmonetizedViewsSpan = document.getElementById('total-unmonetized-views');
        const estimatedEarningsSpan = document.getElementById('estimated-earnings');
        const withdrawBtn = document.getElementById('withdraw-btn');
        const withdrawalStatusDiv = document.getElementById('withdrawal-status');

        const withdrawModal = document.getElementById('withdraw-modal');
        const currentMintBalance = document.getElementById('current-mint-balance');
        const withdrawPaypalEmail = document.getElementById('withdraw-paypal-email');
        const withdrawRealName = document.getElementById('withdraw-real-name');
        const withdrawAge = document.getElementById('withdraw-age');
        const withdrawDob = document.getElementById('withdraw-dob');
        const confirmWithdrawBtn = document.getElementById('confirm-withdraw-btn');
        const closeWithdrawModalBtn = document.getElementById('close-withdraw-modal');

        // Language Selection Modal for Translate
        const languageSelectModal = document.getElementById('language-select-modal');
        const languageOptionsContainer = document.querySelector('#language-select-modal .language-options');
        const saveLanguageBtn = document.getElementById('save-language-btn');
        const cancelLanguageBtn = document.getElementById('cancel-language-btn');


        // --- Global Variables & Flags ---
        let currentUser = null; 
        let currentProfileViewingId = null;
        let currentChatPartnerId = null;

        let lastVisiblePost = null; 
        let fetchingPosts = false; 

        let postsToLoadPerScroll = 10; 

        let dataSaverEnabled = false; 
        let userSelectedTranslationLanguage = 'en'; // Default language for translation simulation

        let currentSpeaker = null; // To track SpeechSynthesisUtterance
        let unsubscribeFromChat = null; // To manage Firestore chat listeners

        let isProcessingAuth = false; // Flag to prevent multiple rapid auth requests (login/signup)
        let hasRunInitialAuthCheck = false; // Flag: ensures onAuthStateChanged's main logic runs only once per page load


        // --- Profile Logos Data (Moved to a single variable at top, outside of `applyLogoStyles` to be shared) ---
        const PROFILE_LOGOS = [
            { class: 'logo-1', emoji: '🧑', color: '#ff6347' }, { class: 'logo-2', emoji: '👩', color: '#6a5acd' }, { class: 'logo-3', emoji: '🚀', color: '#32cd32' },
            { class: 'logo-4', emoji: '💡', color: '#ff8c00' }, { class: 'logo-5', emoji: '🌟', color: '#ffd700' }, { class: 'logo-6', emoji: '🌈', color: '#9932cc' },
            { class: 'logo-7', emoji: '🦊', color: '#d2691e' }, { class: 'logo-8', emoji: '🐼', color: '#6495ed' }, { class: 'logo-9', emoji: '🦋', color: '#dda0dd' },
            { class: 'logo-10', emoji: '🐢', color: '#20b2aa' }, { class: 'logo-11', emoji: '🤖', color: '#87ceeb' }, { class: 'logo-12', emoji: '👽', color: '#7cfc00' },
            { class: 'logo-13', emoji: '🦄', color: '#ee82ee' }, { class: 'logo-14', emoji: '🐉', color: '#48d1cc' }, { class: 'logo-15', emoji: '🌊', color: '#4682b4' },
            { class: 'logo-16', emoji: '🔥', color: '#dc143c' }, { class: 'logo-17', emoji: '👑', color: '#f0e68c' }, { class: 'logo-18', emoji: '💎', color: '#00ced1' },
            { class: 'logo-19', emoji: '🔑', color: '#b0e0e6' }, { class: 'logo-20', emoji: '⚡', color: '#ffff00' }, { class: 'logo-21', emoji: '🎵', color: '#ff69b4' },
            { class: 'logo-22', emoji: '🎨', color: '#7b68ee' }, { class: 'logo-23', emoji: '🧩', color: '#ffa07a' }, { class: 'logo-24', emoji: '🍔', color: '#cd853f' },
            { class: 'logo-25', emoji: '🍕', color: '#f08080' }, { class: 'logo-26', emoji: '🎮', color: '#c0c0c0' }, { class: 'logo-27', emoji: '✈️', color: '#afeeee' },
            { class: 'logo-28', emoji: '🌳', color: '#228b22' }, { class: 'logo-29', emoji: '🌸', color: '#ffb6c1' }, { class: 'logo-30', emoji: '⚽', color: '#b0c4de' },
            { class: 'logo-31', emoji: '🎸', color: '#8b4513' }, { class: 'logo-32', emoji: '🚲', color: '#00fa9a' }, { class: 'logo-33', emoji: '📚', color: '#deb887' },
            { class: 'logo-34', emoji: '☕', color: '#d2b48c' }, { class: 'logo-35', emoji: '🎁', color: '#f4a460' }, { class: 'logo-36', emoji: '🎉', color: '#ba55d3' },
            { class: 'logo-37', emoji: '🌍', color: '#87cefa' }, { class: 'logo-38', emoji: '🔬', color: '#778899' }, { class: 'logo-39', emoji: '🔭', color: '#696969' },
            { class: 'logo-40', emoji: '🛠️', color: '#d3d3d3' }, { class: 'logo-41', emoji: '⚖️', color: '#add8e6' }, { class: 'logo-42', emoji: '💰', color: '#b8860b' },
            { class: 'logo-43', emoji: '🛡️', color: '#5f9ea0' }, { class: 'logo-44', emoji: '🔔', color: '#f0f8ff' }, { class: 'logo-45', emoji: '⏳', color: '#fa8072' },
            { class: 'logo-46', emoji: '💾', color: '#3cb371' }, { class: 'logo-47', emoji: '⚙️', color: '#4682b4' }, { class: 'logo-48', emoji: '📡', color: '#2e8b57' },
            { class: 'logo-49', emoji: '🌐', color: '#a52a2a' }, { class: 'logo-50', emoji: '📈', color: '#c71585' }
        ];

        // --- Utility Functions ---

        // Display a small toast notification on screen
        function showToast(message, type = 'info', duration = 3000) {
            console.log(`Toast (${type}): ${message}`); // Log all toasts for debugging
            toastNotification.textContent = message;
            toastNotification.className = `toast-notification show ${type}`; // Add type for styling (e.g., 'error', 'success')
            setTimeout(() => {
                toastNotification.className = 'toast-notification';
            }, duration);
        }

        // Update authentication form status messages (login, signup, reset password modals)
        function updateAuthStatus(element, message, type) {
            element.textContent = message;
            element.className = `status-message ${type}`; // Set styling class
            element.style.display = (type === 'hidden' || message === '') ? 'none' : 'block'; // Show/hide based on content/type
        }


        // Format large numbers for display (e.g., 12000 -> 12k)
        function formatNumber(num) {
            if (num === undefined || num === null) return 0; // Handle undefined/null gracefully
            if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M'; // Millions
            if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k'; // Thousands
            return num; // Default for smaller numbers
        }

        // Show specific application screen sections and update bottom navigation active state
        function showScreen(screenId) {
            console.log(`UI: Attempting to show screen: ${screenId}`);
            // Hide all screen sections first
            screenSections.forEach(screen => {
                screen.classList.remove('active');
            });
            // Show the target screen by adding 'active' class
            document.getElementById(screenId).classList.add('active');

            // Update active state in bottom navigation menu
            bottomNavItems.forEach(item => {
                if (item.dataset.screen === screenId.replace('-screen', '')) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });

            // Close sidebar if open
            sidebar.classList.remove('open');
            console.log(`UI: Screen ${screenId} is now active.`);
        }

        // Generate a random logo class from the predefined PROFILE_LOGOS array
        function getRandomLogoClass() {
            const randomIndex = Math.floor(Math.random() * PROFILE_LOGOS.length);
            return PROFILE_LOGOS[randomIndex].class;
        }

        // Get the corresponding CSS class name for a profile logo based on its stored 'class' string
        function getLogoCssClass(logoName) {
            const logo = PROFILE_LOGOS.find(l => l.class === logoName);
            return logo ? `user-${logo.class}` : 'user-logo-1'; // Fallback to a default logo if not found
        }

        // Dynamically inject CSS styles for profile logos. This makes the emoji and background color appear.
        function applyLogoStyles() {
            PROFILE_LOGOS.forEach(logo => {
                // Prevent duplicate style tags
                if (!document.head.querySelector(`style[data-logo-class="${logo.class}"]`)) {
                    const style = document.createElement('style');
                    style.setAttribute('data-logo-class', logo.class); // Custom attribute for easy lookup
                    style.innerHTML = `
                        .profile-avatar.user-${logo.class}, .profile-avatar-large.user-${logo.class}, .profile-avatar-small.user-${logo.class}, .logo-option-item.user-${logo.class} { background-color: ${logo.color}; }
                        .profile-avatar.user-${logo.class}::before, .profile-avatar-large.user-${logo.class}::before, .profile-avatar-small.user-${logo.class}::before, .logo-option-item.user-${logo.class}::before { content: '${logo.emoji}'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: ${logo.class.includes('large') ? '60px' : logo.class.includes('small') ? '30px' : '24px'}; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--button-primary-text); }
                    `;
                    document.head.appendChild(style);
                }
            });
        }
        applyLogoStyles(); // Call once when the script starts executing.


        // --- Core Authentication Flow & UI Management ---

        // Display the authentication container (Login/Signup screens).
        function showAuthContainerUI() {
            console.log("Function: showAuthContainerUI() initiated.");
            appContainer.classList.add('hidden'); // Hide main app UI
            appContainer.style.display = 'none'; // Ensure no visibility conflict

            authContainer.classList.remove('hidden'); // Make auth container visible
            authContainer.style.display = 'flex'; // Set to flex to handle centering within auth-container

            loginScreen.classList.add('active'); // Default to login screen active
            signupScreen.classList.remove('active'); // Ensure signup is inactive

            console.log("UI: Authentication screens are now visible. App container is hidden.");
        }

        // Display the main application container (Home Feed, Profile, etc.).
        function showAppContainerUI() {
            console.log("Function: showAppContainerUI() initiated.");
            authContainer.classList.add('hidden'); // Hide auth UI
            authContainer.style.display = 'none'; // Ensure no visibility conflict

            appContainer.classList.remove('hidden'); // Make app container visible
            appContainer.style.display = 'flex'; // Set to flex for main app layout
            console.log("UI: Main App screens are now visible. Auth container is hidden.");
        }

        // Central handler for Firebase authentication state changes.
        // This function orchestrates which part of the UI to show (auth vs. main app).
        async function checkUserAndRedirect(user) {
            console.log(`checkUserAndRedirect called. User: ${user ? user.uid : "None"}. Email Verified: ${user ? user.emailVerified : "N/A"}.`);
            
            // This `onAuthStateChanged` handler can fire multiple times. Prevent re-initialization on stable state.
            if (hasRunInitialAuthCheck && user === auth.currentUser) {
                console.log("checkUserAndRedirect: Already performed initial check for this state, skipping.");
                return;
            }
            hasRunInitialAuthCheck = true; // Mark as having started processing the initial auth state.

            // Immediately hide the JS load indicator once we start processing auth, as we're about to show the main UI.
            if (loadStatusElement) {
                loadStatusElement.style.display = 'none'; // Hide the "Loading Application..." message.
                console.log("Diagnostic: Initial loading message hidden (main UI path taking over).");
            }

            if (user && user.emailVerified) {
                currentUser = user; // Set the global current user object.
                console.log(`User ${user.uid} is authenticated and email verified. Attempting to load user profile.`);
                try {
                    const userDocRef = db.collection('users').doc(currentUser.uid);
                    const userDoc = await userDocRef.get();
                    const userData = userDoc.data();

                    // Check if user document exists AND if username and name fields are properly set (not empty strings).
                    // A new registered user will NOT have username/name immediately, so we redirect them.
                    if (!userDoc.exists || !userData.username || userData.username === "" || !userData.name || userData.name === "") {
                        console.log("User profile incomplete (missing username or display name). Forcing profile setup flow.");
                        showAppContainerUI(); // Display the main app container where profile modal will live.
                        showScreen('profile-screen'); // Navigate to the profile tab.
                        editProfileModal.classList.remove('hidden'); // Automatically open the edit profile modal.
                        profileModalInstruction.textContent = "Welcome! Please complete your profile (Username and Display Name are required) to continue using the app.";
                        myProfileUsername.textContent = "@NewUser"; // Temporary UI placeholders.
                        sidebarUsername.textContent = "New User";
                        sidebarProfileAvatar.className = `profile-avatar-small ${getLogoCssClass('logo-1')}`; // Default avatar.
                        showToast("Welcome! Please complete your profile (Username and Display Name are required).", 'info', 7000);
                    } else {
                        console.log("User profile is complete. Displaying main application UI.");
                        loadUserProfile(currentUser.uid); // Load all user-specific data and update UI components.
                        showAppContainerUI(); // Display the full main app UI.
                        showScreen('home-screen'); // Default to home feed.
                        loadPosts(); // Start loading the content for the feed.
                        showToast("Logged in successfully!", 'success');
                    }
                } catch (firestoreError) {
                    console.error("Firebase Firestore error during user profile load (check rules or data structure):", firestoreError);
                    showToast("Error loading user profile. Please check your internet or try logging in again. (Check console for Firestore rules issues.)", 'error', 8000);
                    auth.signOut(); // Critical error here, forcing logout.
                    showAuthContainerUI(); // Fallback to authentication UI.
                }
            } else { // No user is logged in (`user` is null) OR `user` is logged in but `emailVerified` is false.
                currentUser = null; // Ensure global user object is null.
                console.log("No authenticated AND verified user found. Displaying Authentication UI.");
                showAuthContainerUI(); // Display the Login/Register screens.

                if (user && !user.emailVerified) { // If a user object exists but email is not verified
                    console.log(`User ${user.uid} authenticated but email is NOT verified. Instructing user for verification.`);
                    updateAuthStatus(loginStatus, "Please verify your email to continue. Check your inbox (or spam folder) for a verification link.", 'info');
                    auth.signOut(); // Sign out unverified users to streamline verification flow on next login attempt.
                } else {
                    console.log("No active user session detected. Showing login form.");
                    updateAuthStatus(loginStatus, "", 'hidden'); // Clear any previous login status messages.
                }
            }
        }


        // Attach authentication state listener early in script execution
        auth.onAuthStateChanged(user => {
            // This is the primary trigger for UI state. It will call `checkUserAndRedirect`.
            console.log("onAuthStateChanged event fired by Firebase SDK.");
            checkUserAndRedirect(user);
        });


        // Handle password visibility toggle for auth forms
        passwordToggles.forEach(toggle => {
            toggle.addEventListener('click', () => {
                const targetId = toggle.dataset.target; // Get the ID of the password input.
                const targetInput = document.getElementById(targetId);
                const icon = toggle.querySelector('i');

                if (targetInput.type === 'password') {
                    targetInput.type = 'text'; // Show password.
                    icon.classList.replace('fa-eye', 'fa-eye-slash'); // Change icon.
                } else {
                    targetInput.type = 'password'; // Hide password.
                    icon.classList.replace('fa-eye-slash', 'fa-eye'); // Change icon back.
                }
            });
        });

        // Auth UI Form switching handlers
        showSignupLink.addEventListener('click', (e) => {
            e.preventDefault();
            loginScreen.classList.remove('active');
            signupScreen.classList.add('active');
            updateAuthStatus(loginStatus, '', 'hidden'); // Clear login messages
            updateAuthStatus(signupStatus, '', 'hidden'); // Clear signup messages
            console.log("UI: Switched to Signup screen.");
        });

        showLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            signupScreen.classList.remove('active');
            loginScreen.classList.add('active');
            updateAuthStatus(loginStatus, '', 'hidden');
            updateAuthStatus(signupStatus, '', 'hidden');
            console.log("UI: Switched to Login screen.");
        });

        forgotPasswordLink.addEventListener('click', (e) => {
            e.preventDefault();
            forgotPasswordModal.classList.remove('hidden'); // Show modal
            updateAuthStatus(resetStatus, '', 'hidden'); // Clear previous status
            resetEmailInput.value = ''; // Clear email input
            console.log("UI: Displayed Forgot Password modal.");
        });

        closeResetModalBtn.addEventListener('click', () => {
            forgotPasswordModal.classList.add('hidden'); // Hide modal
            console.log("UI: Closed Forgot Password modal.");
        });

        // Attach event listeners for auth buttons
        loginBtn.addEventListener('click', signInUser);
        signupBtn.addEventListener('click', registerUser);
        sendResetEmailBtn.addEventListener('click', sendPasswordReset);


        // Handle user sign-in process
        async function signInUser() {
            if (isProcessingAuth) { 
                console.warn("Authentication process already ongoing. Skipping re-request.");
                return;
            }
            isProcessingAuth = true; 
            loginBtn.disabled = true; // Disable login button.

            const email = loginEmailInput.value.trim();
            const password = loginPasswordInput.value.trim();

            if (!email || !password) {
                updateAuthStatus(loginStatus, "Please enter both email and password.", 'error');
                isProcessingAuth = false; // Reset flags
                loginBtn.disabled = false;
                return;
            }

            try {
                console.log(`Attempting user sign-in for: ${email}`);
                updateAuthStatus(loginStatus, "Logging in...", 'info');
                await auth.signInWithEmailAndPassword(email, password);
                // Success: `onAuthStateChanged` listener will handle redirection.
                console.log("Firebase signInWithEmailAndPassword succeeded.");
                loginEmailInput.value = ''; // Clear inputs
                loginPasswordInput.value = '';
            } catch (error) {
                console.error("Firebase Sign-in error:", error.code, error.message);
                let errorMessage = "Login failed. Please check your email and password.";
                // Provide user-friendly messages for common auth errors.
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid email or password. Please try again.";
                } else if (error.code === 'auth/too-many-requests') {
                    errorMessage = "Too many failed login attempts. Please try again later.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Network error. Check your internet connection.";
                } else if (error.code === 'auth/user-disabled') {
                    errorMessage = "Your account has been disabled. Contact support.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email format. Please check.";
                } else if (error.code === 'auth/internal-error') {
                    errorMessage = "Server error. Please try again later.";
                }
                updateAuthStatus(loginStatus, errorMessage, 'error');
            } finally {
                isProcessingAuth = false; // Always reset flag.
                loginBtn.disabled = false; // Always re-enable button.
            }
        }

        // Handle user registration process
        async function registerUser() {
            if (isProcessingAuth) { 
                console.warn("Authentication process already ongoing. Skipping re-request.");
                return;
            }
            isProcessingAuth = true; 
            signupBtn.disabled = true; // Disable signup button.

            const email = signupEmailInput.value.trim();
            const password = signupPasswordInput.value.trim();
            const confirmPassword = signupConfirmPasswordInput.value.trim();

            if (!email || !password || !confirmPassword) {
                updateAuthStatus(signupStatus, "All fields are required.", 'error');
                isProcessingAuth = false;
                signupBtn.disabled = false;
                return;
            }
            if (password.length < 6) {
                updateAuthStatus(signupStatus, "Password must be at least 6 characters long.", 'error');
                isProcessingAuth = false;
                signupBtn.disabled = false;
                return;
            }
            if (password !== confirmPassword) {
                updateAuthStatus(signupStatus, "Passwords do not match.", 'error');
                isProcessingAuth = false;
                signupBtn.disabled = false;
                return;
            }

            try {
                console.log("Attempting user registration for:", email);
                updateAuthStatus(signupStatus, "Registering user...", 'info');
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                await sendEmailVerification(userCredential.user); 

                // Create initial user document in Firestore with placeholder data for required profile fields.
                await db.collection('users').doc(userCredential.user.uid).set({
                    uid: userCredential.user.uid,
                    email: userCredential.user.email,
                    username: "", // Placeholder - user will set in profile edit
                    name: "",     // Placeholder - user will set in profile edit
                    bio: "", // Optional, default empty
                    whatsapp: "", // Optional
                    instagram: "", // Optional
                    profileLogo: getRandomLogoClass(), // Assign random default logo
                    profilePicUrl: "", // Optional, empty
                    isPrivate: false, // Default to public
                    followers: [],
                    following: [],
                    followersCount: 0,
                    followingCount: 0,
                    postCount: 0,
                    monetizedViewsCount: 0,
                    unmonetizedViewsCount: 0,
                    earnedAmount: 0.00,
                    reposts: [],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                console.log("User registered and initial profile doc created. Showing verification message.");
                updateAuthStatus(signupStatus, "Registration successful! Please verify your email.", 'success');
                signupEmailInput.value = '';
                signupPasswordInput.value = '';
                signupConfirmPasswordInput.value = '';
                // After successful registration, switch to login screen for verification instructions.
                showAuthScreen('login'); // Call directly to manage UI
                updateAuthStatus(loginStatus, "Registered! Check your inbox (or spam) to verify email, then login.", 'info');

            } catch (error) {
                console.error("Firebase Registration error:", error.code, error.message);
                let errorMessage = "Registration failed.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "This email is already in use. Please log in instead.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email format. Please check.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Password is too weak (min 6 chars).";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Network error during registration. Check internet.";
                }
                updateAuthStatus(signupStatus, errorMessage, 'error');
            } finally {
                isProcessingAuth = false; // Always reset flag.
                signupBtn.disabled = false; // Always re-enable button.
            }
        }

        // Send password reset email
        async function sendPasswordReset() {
            if (isProcessingAuth) {
                console.warn("Authentication process already ongoing.");
                return;
            }
            isProcessingAuth = true;
            sendResetEmailBtn.disabled = true; // Disable button.

            const email = resetEmailInput.value.trim();
            if (!email) {
                updateAuthStatus(resetStatus, "Please enter your email.", 'error');
                isProcessingAuth = false;
                sendResetEmailBtn.disabled = false;
                return;
            }

            try {
                console.log("Sending password reset email for:", email);
                await auth.sendPasswordResetEmail(email);
                updateAuthStatus(resetStatus, "Password reset link sent to your email! Please check your inbox.", 'success');
            } catch (error) {
                console.error("Firebase Forgot password error:", error.code, error.message);
                let errorMessage = "Failed to send reset link.";
                if (error.code === 'auth/user-not-found') {
                    errorMessage = "No account found with that email address.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email format. Please check.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Network error. Check your internet connection.";
                }
                updateAuthStatus(resetStatus, errorMessage, 'error');
            } finally {
                isProcessingAuth = false;
                sendResetEmailBtn.disabled = false; // Re-enable button.
            }
        }

        // Handle user logout
        document.getElementById('logout-btn').addEventListener('click', async () => {
            try {
                console.log("Attempting user logout.");
                await auth.signOut();
                showToast("Logged out successfully.", 'info');

                // Clear input fields and reset state for security and a fresh start.
                loginEmailInput.value = '';
                loginPasswordInput.value = '';
                signupEmailInput.value = '';
                signupPasswordInput.value = '';
                signupConfirmPasswordInput.value = '';
                editUsernameInput.value = '';
                editNameInput.value = '';
                editBioInput.value = '';
                editWhatsappInput.value = '';
                editInstagramInput.value = '';
                profilePicUrlInput.value = '';
                
                // Reset the flag so that onAuthStateChanged will perform its full check next time.
                hasRunInitialAuthCheck = false; 

                // UI redirection will be automatically handled by the `onAuthStateChanged` listener.
                // It will detect the user as logged out and redirect to authentication screens.
            } catch (error) {
                console.error("Error during logout:", error);
                showToast("Failed to log out. Please try again.", 'error');
            }
        });


        // --- Initial App Load Logic (Triggered on DOMContentLoaded) ---
        // This function will run once the HTML is fully parsed and loaded.
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired. Beginning initial app initialization sequence.");
            
            // 1. Initially hide both main app and authentication UI containers using CSS .hidden.
            appContainer.classList.add('hidden'); 
            authContainer.classList.add('hidden'); 

            // 2. Make the 'load-status' indicator visible immediately.
            // This is crucial for debugging to confirm JavaScript has started execution.
            if (loadStatusElement) {
                loadStatusElement.textContent = "Loading Application...";
                loadStatusElement.style.display = 'block'; 
                console.log("Diagnostic: 'load-status' message is now displayed.");
            } else {
                console.warn("Diagnostic: 'load-status' element not found in DOM.");
            }

            // 3. Initiate the Firebase authentication state check immediately.
            // This is the primary trigger for UI state. `onAuthStateChanged` will handle actual rendering.
            // We give it a short buffer to run before any fallbacks.
            setTimeout(() => {
                console.log("DOM ready for auth check. Triggering Firebase `onAuthStateChanged` handler.");
                // `onAuthStateChanged` handler itself will call `checkUserAndRedirect(user)`.
            }, 50); // Small delay to allow DOM to be fully painted and Firebase SDK a tiny buffer.

            // 4. Set a fallback timeout for the `onAuthStateChanged` listener.
            // In rare cases where `onAuthStateChanged` might be delayed (e.g., severe network issues, SDK fail),
            // this ensures the UI still proceeds after a fixed maximum delay (e.g., 3 seconds).
            splashScreenTimeout = setTimeout(() => {
                if (!hasRunInitialAuthCheck) { 
                    console.warn("Fallback: Authentication state check forced due to primary delay. UI should now proceed.");
                    checkUserAndRedirect(auth.currentUser); // Force UI transition based on current Firebase state.
                }
            }, 3000); // Max 3 seconds for initial UI setup.
        });


        // --- Data Saver Toggle Functionality ---
        document.getElementById('data-saver-checkbox').addEventListener('change', (e) => {
            dataSaverEnabled = e.target.checked;
            showToast(`Data Saver ${dataSaverEnabled ? 'Enabled' : 'Disabled'}`, 'info');
            // Future enhancement: Add logic here to load lower resolution images or prioritize text over media.
        });


        // --- Dark Mode Toggle Functionality ---
        darkModeCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                body.classList.add('dark-mode');
                body.classList.remove('light-mode');
                localStorage.setItem('theme', 'dark'); // Save user preference
            } else {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                localStorage.setItem('theme', 'light'); // Save user preference
            }
            showToast(`Dark Mode ${e.target.checked ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Load and apply initial theme setting from local storage.
        document.addEventListener('DOMContentLoaded', () => { 
            const savedTheme = localStorage.getItem('theme') || 'dark'; // Default to dark theme if no preference.
            if (savedTheme === 'light') {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                darkModeCheckbox.checked = false; // Reflect setting in UI.
            } else {
                body.classList.add('dark-mode');
                body.classList.remove('light-mode');
                darkModeCheckbox.checked = true; // Reflect setting in UI.
            }
        });


        // --- Sidebar Navigation Control ---
        menuToggle.addEventListener('click', () => {
            sidebar.classList.add('open'); // Open sidebar.
        });

        closeSidebarBtn.addEventListener('click', () => {
            sidebar.classList.remove('open'); // Close sidebar.
        });

        sidebar.querySelectorAll('ul li a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const screenId = e.currentTarget.dataset.screen; // Get target screen ID.
                if (screenId) {
                    showScreen(`${screenId}-screen`); // Switch to the selected main screen

                    // Execute screen-specific loading functions
                    if (screenId === 'profile') {
                        loadUserProfile(currentUser.uid); // Load own profile data for sidebar link
                        currentProfileViewingId = currentUser.uid;
                    } else if (screenId === 'messages') {
                        loadRecentChats(); // Load recent chat conversations.
                        messageListContainer.classList.remove('hidden'); // Show message list.
                        chatWindowContainer.classList.add('hidden'); // Ensure chat window is hidden when returning to list.
                    } else if (screenId === 'home') {
                        postsFeed.innerHTML = ''; // Clear feed for fresh load.
                        lastVisiblePost = null; // Reset pagination.
                        loadPosts(); // Load posts from beginning.
                        postCategoryFilter.value = 'all'; // Reset category filter selection.
                    } else if (screenId === 'feed') {
                        // For 'immersive feed', this is a placeholder. You'd need a separate fetch.
                        console.log("Immersive Feed not fully implemented yet."); // Placeholder for immersive feed logic.
                    } else if (screenId === 'earnings') {
                        loadEarningsPage(); // Load user's earning details.
                    }
                }
                sidebar.classList.remove('open'); // Close sidebar after clicking a link.
            });
        });


        // --- Bottom Navigation Control ---
        bottomNavItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const screenId = e.currentTarget.dataset.screen; // Get target screen ID.
                showScreen(`${screenId}-screen`); // Switch to the selected screen.

                // Execute screen-specific loading functions (similar to sidebar)
                if (screenId === 'profile') {
                    loadUserProfile(currentUser.uid);
                    currentProfileViewingId = currentUser.uid;
                } else if (screenId === 'messages') {
                    loadRecentChats();
                    messageListContainer.classList.remove('hidden');
                    chatWindowContainer.classList.add('hidden');
                } else if (screenId === 'home') {
                    postsFeed.innerHTML = '';
                    lastVisiblePost = null;
                    loadPosts();
                    postCategoryFilter.value = 'all';
                } else if (screenId === 'search') {
                    searchUserList.innerHTML = ''; // Clear search results.
                    searchPostList.innerHTML = '';
                    noSearchResults.classList.add('hidden');
                    searchQueryInput.value = ''; // Clear search input field.
                } else if (screenId === 'upload') {
                    // Reset upload form inputs.
                    postContentInput.value = '';
                    monetizePostCheckbox.checked = false;
                    uploadStatus.textContent = '';
                }
            });
        });


        // --- Post Loading and Infinite Scrolling (Home Feed) ---
        postCategoryFilter.addEventListener('change', () => {
            postsFeed.innerHTML = ''; // Clear posts on category change.
            lastVisiblePost = null; // Reset pagination for new filter.
            loadPosts(); // Reload posts based on new filter.
        });

        async function loadPosts() {
            if (!currentUser) { 
                console.log("loadPosts: Skipping. No user logged in.");
                return;
            }
            if (fetchingPosts) { 
                console.log("loadPosts: Skipping. Already fetching posts.");
                return;
            }

            fetchingPosts = true; // Set flag to indicate fetching.
            loadingSpinner.classList.remove('hidden'); // Show loading spinner.
            console.log("loadPosts: Starting post fetch for home feed.");

            try {
                let postsBaseRef = db.collection('posts')
                                .where('expiryTime', '>', firebase.firestore.Timestamp.now()) // Only retrieve active (non-expired) posts.
                                .orderBy('expiryTime', 'desc') // Sort by expiry date (newer posts first).
                                .orderBy('timestamp', 'desc'); // Secondary sort by creation timestamp for consistent order.


                const selectedCategory = postCategoryFilter.value;
                if (selectedCategory !== 'all') {
                    postsBaseRef = postsBaseRef.where('category', '==', selectedCategory); // Apply category filter.
                    console.log(`loadPosts: Filtering by category: ${selectedCategory}`);
                }

                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const followedUsers = userDoc.data().following || [];
                console.log(`loadPosts: Current user following ${followedUsers.length} users.`);


                let fetchedPosts = []; // Array to collect all fetched posts (from followed and general).

                // 1. Fetch posts from followed users (chunked due to Firestore's 'in' query limit of 10).
                if (followedUsers.length > 0) {
                    const chunkSize = 10; 
                    for (let i = 0; i < followedUsers.length; i += chunkSize) {
                        const chunk = followedUsers.slice(i, i + chunkSize);
                        let currentFollowedQuery = postsBaseRef.where('userId', 'in', chunk);
                        
                        // For combined pagination logic across different queries (followed vs. general), 
                        // it's generally simpler to fetch a larger batch and then paginate client-side, 
                        // or use a Cloud Function to pre-aggregate a custom feed for complex ordering.
                        // For this example, we fetch a bit more from followed users.
                        const followedSnapshot = await currentFollowedQuery.limit(postsToLoadPerScroll * 2).get();

                        followedSnapshot.docs.forEach(doc => {
                            if (!fetchedPosts.some(p => p.id === doc.id)) { // Prevent duplicates if same post is returned across chunks or mixed in with general.
                                 fetchedPosts.push({ id: doc.id, ...doc.data() });
                            }
                        });
                        console.log(`loadPosts: Fetched ${followedSnapshot.size} posts from followed users chunk.`);
                    }
                }

                // 2. Fetch general public posts to fill up the desired feed size or as main content if no followed users.
                let generalPostsRef = postsBaseRef.where('isPrivate', '==', false); // Only public posts for this part of the feed.
                
                // If it's the very first load or if no followed posts were retrieved, use general posts for pagination.
                // If lastVisiblePost exists and fetchedPosts are few, means previous pagination hit end for followed.
                // It's very complex to paginate across multiple WHERE clauses using Firestore directly this way.
                // For 'never-ending' and complex feeds, Cloud Functions would typically pre-generate / paginate feeds.
                
                // Simpler pagination fallback for general public posts if we didn't fill up from followed.
                // This will restart pagination for general posts only.
                if (lastVisiblePost && (followedUsers.length === 0 || fetchedPosts.length < postsToLoadPerScroll)) {
                     generalPostsRef = generalPostsRef.startAfter(lastVisiblePost);
                     console.log("loadPosts: Adding general posts with pagination.");
                } else if (!lastVisiblePost && fetchedPosts.length === 0) {
                    // First load, no followed, just general
                     console.log("loadPosts: First load, only general posts.");
                } else {
                     // We have enough from followed, or just mixing without deep pagination across feed types
                     // To ensure some general content is always loaded along side followed:
                     generalPostsRef = generalPostsRef; // No startAfter for mixed content load if not strictly paginating
                }

                const generalPostsSnapshot = await generalPostsRef.limit(postsToLoadPerScroll).get();
                generalPostsSnapshot.docs.forEach(doc => {
                    if (!fetchedPosts.some(p => p.id === doc.id)) { // Avoid adding duplicates that might already be from followed.
                       fetchedPosts.push({ id: doc.id, ...doc.data() });
                    }
                });
                if (!generalPostsSnapshot.empty) {
                    // Only update lastVisiblePost if general posts were actually added in this round of fetching
                    // And they contributed to advancing the pointer.
                    if (!lastVisiblePost || generalPostsSnapshot.docs[generalPostsSnapshot.docs.length - 1].id !== lastVisiblePost.id) {
                        lastVisiblePost = generalPostsSnapshot.docs[generalPostsSnapshot.docs.length - 1];
                    }
                }
                console.log(`loadPosts: Added ${generalPostsSnapshot.size} posts from general feed portion.`);


                // 3. Post-fetch processing: Filter already-displayed posts and manage 'never-ending' logic.
                const alreadyDisplayedPostIds = new Set(Array.from(postsFeed.children).map(el => el.dataset.postId));
                let newPostsToRender = fetchedPosts.filter(post => !alreadyDisplayedPostIds.has(post.id));

                console.log(`loadPosts: Total unique posts fetched: ${fetchedPosts.length}, genuinely new posts to render: ${newPostsToRender.length}.`);

                if (newPostsToRender.length === 0 && fetchedPosts.length > 0 && postsFeed.children.length > 0) {
                    // If we fetched posts, but they were all duplicates already on screen, or no new content to add, then loop.
                    showToast("No new unique posts found. Looping feed to older content...", 'info', 3000);
                    lastVisiblePost = null; // Reset pagination to loop back to the beginning of the entire feed.
                    console.log("loadPosts: Resetting lastVisiblePost for feed loop.");
                    
                    postsFeed.innerHTML = ''; // Clear existing posts to show content from the beginning of the feed.
                    fetchingPosts = false; // Release lock for immediate recursive call.
                    return loadPosts(); // Recursively call to get first batch of new loop.

                } else if (newPostsToRender.length === 0 && postsFeed.children.length === 0) {
                    // Special case: If after initial load (or after loop reset) there are still no posts available.
                    showToast("No posts available in this feed. Start by uploading one!", 'info', 5000);
                    postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No posts available in this feed. Try uploading one!</p>';
                    loadingSpinner.classList.add('hidden');
                    fetchingPosts = false;
                    return;
                } else if (newPostsToRender.length === 0) { // Fetched some, but all are already displayed AND feed is not empty. Just say nothing new.
                     console.log("loadPosts: All fetched posts were already displayed.");
                     showToast("No new posts at the moment.", 'info', 2000);
                     loadingSpinner.classList.add('hidden');
                     fetchingPosts = false;
                     return;
                }


                // Clear feed only if it's explicitly the start of a full loop or initial empty state.
                if (lastVisiblePost === null && postsFeed.innerHTML.trim() !== '' && !newPostsToRender.some(p => !alreadyDisplayedPostIds.has(p.id))) {
                     // This condition is for when the feed is implicitly resetting because of no new content from original order.
                     postsFeed.innerHTML = ''; // Clear previous content if we are effectively starting fresh from top of looped data.
                }


                // Randomize and render the NEW posts
                let tempPostsForRendering = [...newPostsToRender];
                while (tempPostsForRendering.length > 0) {
                    const randomLayout = Math.floor(Math.random() * 3); // 0: vertical, 1: horizontal, 2: table
                    const post = tempPostsForRendering.shift();

                    if (randomLayout === 0 || tempPostsForRendering.length < 4) { 
                        renderPost(post, postsFeed, 'vertical-post');
                    } else if (randomLayout === 1 && tempPostsForRendering.length >= 2) {
                        const numHorizontal = Math.min(tempPostsForRendering.length, Math.floor(Math.random() * 2) + 2); // 2 or 3 posts
                        const horizontalContainer = document.createElement('div');
                        horizontalContainer.className = 'horizontal-post-container';
                        for (let i = 0; i < numHorizontal; i++) {
                            horizontalContainer.appendChild(createPostElement(tempPostsForRendering.shift(), 'horizontal-post'));
                        }
                        postsFeed.appendChild(horizontalContainer);
                    } else if (randomLayout === 2 && tempPostsForRendering.length >= 4) {
                        const numTable = Math.min(tempPostsForRendering.length, Math.floor(Math.random() * 3) + 4); // 4, 5, or 6 posts
                        const tableContainer = document.createElement('div');
                        tableContainer.className = 'table-post-container';
                        for (let i = 0; i < numTable; i++) {
                            tableContainer.appendChild(createPostElement(tempPostsForRendering.shift(), 'table-post'));
                        }
                        postsFeed.appendChild(tableContainer);
                    } else { 
                        renderPost(post, postsFeed, 'vertical-post'); // Default fallback if no specific layout applies
                    }
                }
                console.log(`loadPosts: Successfully rendered ${newPostsToRender.length} posts to the DOM.`);

            } catch (error) {
                console.error("Critical error loading posts for home feed (ensure Firebase Rules are correctly published):", error);
                showToast("Error loading posts. Please refresh your page or check console for more details.", 'error', 7000);
            } finally {
                loadingSpinner.classList.add('hidden'); // Hide spinner regardless of success/fail
                fetchingPosts = false; // Release the fetch lock
                console.log("loadPosts: Post fetching process completed.");
            }
        }


        // Immersive Feed (Snap Scrolling) Loading Logic - Similar to loadPosts but for full-screen view.
        async function loadImmersiveFeedPosts() {
            if (!currentUser) { 
                console.log("loadImmersiveFeedPosts: Skipping. No current user.");
                return;
            }
            if (fetchingImmersivePosts) { 
                console.log("loadImmersiveFeedPosts: Skipping. Already fetching.");
                return;
            }

            fetchingImmersivePosts = true;
            feedLoadingSpinner.classList.remove('hidden');
            console.log("loadImmersiveFeedPosts: Starting fetch for immersive feed.");

            try {
                let postsRef = db.collection('posts')
                                 .where('expiryTime', '>', firebase.firestore.Timestamp.now())
                                 .where('isPrivate', '==', false) // Immersive feed only shows public posts
                                 .orderBy('expiryTime', 'desc')
                                 .orderBy('timestamp', 'desc');


                if (lastVisibleImmersivePost) {
                    postsRef = postsRef.startAfter(lastVisibleImmersivePost);
                    console.log("loadImmersiveFeedPosts: Starting after last visible post for pagination.");
                }

                const snapshot = await postsRef.limit(postsToLoadPerScroll).get();

                if (snapshot.empty) {
                    console.log("loadImmersiveFeedPosts: No more posts found. Resetting for loop.");
                    showToast("No more immersive posts. Looping back...", 'info', 3000);
                    lastVisibleImmersivePost = null; // Reset to loop from the beginning
                    fetchingImmersivePosts = false; // Release flag before recursion
                    feedLoadingSpinner.classList.add('hidden');
                    if (immersiveFeed.children.length === 0 || immersiveFeed.innerHTML.includes('No immersive posts available.')) {
                         immersiveFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No immersive posts available. Try uploading a public post!</p>';
                         return; // Avoid infinite recursion if DB is truly empty.
                    } else {
                         immersiveFeed.innerHTML = ''; // Clear for fresh start of looped content.
                         return loadImmersiveFeedPosts(); // Recursive call to get the first batch of the new loop.
                    }
                }

                lastVisibleImmersivePost = snapshot.docs[snapshot.docs.length - 1]; // Update pagination cursor

                const fetchedPosts = [];
                snapshot.docs.forEach(doc => {
                    fetchedPosts.push({ id: doc.id, ...doc.data() });
                });
                console.log(`loadImmersiveFeedPosts: Fetched ${fetchedPosts.length} posts.`);

                // Filter out posts that are already displayed to avoid duplicates.
                const alreadyDisplayedImmersivePostIds = new Set(Array.from(immersiveFeed.children).map(el => el.dataset.postId));
                const newPostsToRender = fetchedPosts.filter(post => !alreadyDisplayedImmersivePostIds.has(post.id));
                
                if (newPostsToRender.length === 0 && fetchedPosts.length > 0 && immersiveFeed.children.length > 0) {
                    console.log("loadImmersiveFeedPosts: Fetched posts were all duplicates, attempting loop reset.");
                    showToast("No new immersive posts. Looping feed...", 'info', 3000);
                    lastVisibleImmersivePost = null; 
                    immersiveFeed.innerHTML = ''; // Clear for fresh content.
                    fetchingImmersivePosts = false;
                    return loadImmersiveFeedPosts(); // Recursive call to load from the beginning.
                } else if (newPostsToRender.length === 0 && immersiveFeed.children.length === 0) {
                    console.log("loadImmersiveFeedPosts: No posts fetched and feed is empty.");
                    showToast("No immersive posts available. Consider uploading a public post!", 'info', 5000);
                    immersiveFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No immersive posts available. Try uploading a public post!</p>';
                    loadingSpinner.classList.add('hidden');
                    fetchingImmersivePosts = false;
                    return;
                }

                // Render posts
                newPostsToRender.forEach(post => {
                    renderPost(post, immersiveFeed, 'immersive-post'); // Append directly to immersiveFeed
                });
                console.log(`loadImmersiveFeedPosts: Rendered ${newPostsToRender.length} new posts.`);


            } catch (error) {
                console.error("Critical error loading immersive feed posts:", error);
                showToast("Error loading immersive feed. Please refresh your page or check console for details.", 'error', 7000);
            } finally {
                feedLoadingSpinner.classList.add('hidden');
                fetchingImmersivePosts = false;
                console.log("loadImmersiveFeedPosts: Fetching finished.");
            }
        }


        function createPostElement(postData, layoutClass = 'vertical-post') {
            const postCard = document.createElement('div');
            postCard.className = `post-card ${layoutClass}`;
            postCard.dataset.postId = postData.id;
            postCard.dataset.userId = postData.userId; // Store userId on the card

            const isOwner = currentUser && postData.userId === currentUser.uid;

            let userAvatarHtml;
            if (postData.profilePicUrl) {
                // If direct picture URL is provided
                userAvatarHtml = `<div class="profile-avatar" style="background-image: url('${postData.profilePicUrl}');" data-user-id="${postData.userId}"></div>`;
            } else {
                // Fallback to emoji logo
                const userProfileClass = getLogoCssClass(postData.userProfileLogo || 'logo-1'); // Default to logo-1 if nothing defined
                userAvatarHtml = `<div class="profile-avatar ${userProfileClass}" data-user-id="${postData.userId}"></div>`;
            }


            postCard.innerHTML = `
                <div class="post-header">
                    ${userAvatarHtml}
                    <span class="username" data-user-id="${postData.userId}">@${postData.username || 'Unknown'}</span>
                    <div class="post-options">
                        <i class="fas fa-ellipsis-v"></i>
                        <div class="options-dropdown hidden">
                            <span class="report-btn">Report</span>
                            <span class="repost-btn">Repost</span>
                            ${isOwner ? `<span class="delete-btn">Delete</span>` : ''}
                        </div>
                    </div>
                </div>
                <div class="post-content">
                    ${formatPostContent(postData.content)}
                </div>
                <div class="post-footer">
                    <div class="post-actions">
                        <span class="like-button"><i class="far fa-heart"></i> <span class="like-count">${formatNumber(postData.likes || 0)}</span></span>
                        <span class="comment-button"><i class="far fa-comment"></i> <span class="comment-count">${formatNumber(postData.commentCount || 0)}</span></span>
                        <span class="views-count"><i class="fas fa-eye"></i> <span class="view-count-num">${formatNumber(postData.views || 0)}</span></span>
                        <span class="speaker-button" title="Listen to Post"><i class="fas fa-volume-up"></i></span>
                        <span class="translate-button" title="Translate Post"><i class="fas fa-language"></i></span>
                    </div>
                    <div class="post-reactions" data-post-id="${postData.id}">
                        ${renderEmojiReactions(postData.reactions)}
                        <span class="total-reactions">${formatNumber(Object.values(postData.reactions || {}).reduce((a, b) => a + b, 0))} reactions</span>
                    </div>
                </div>
                <div class="emoji-picker hidden">
                    <span class="emoji-option" data-emoji="👍">👍</span>
                    <span class="emoji-option" data-emoji="❤️">❤️</span>
                    <span class="emoji-option" data-emoji="😂">😂</span>
                    <span class="emoji-option" data-emoji="😢">😢</span>
                    <span class="emoji-option" data-emoji="🔥">🔥</span>
                </div>
            `;

            addPostEventListeners(postCard, postData);
            return postCard;
        }

        function renderPost(postData, container, layoutClass = 'vertical-post') {
            const postElement = createPostElement(postData, layoutClass);
            container.appendChild(postElement);
        }

        function formatPostContent(content) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return content.replace(urlRegex, (url) => `<a href="${url}" target="_blank" style="color: #00ffff; text-decoration: underline;">${url}</a>`);
        }

        function renderEmojiReactions(reactions) {
            if (!reactions) return '';
            const topEmojis = Object.entries(reactions)
                .filter(([, count]) => count > 0)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 3);
            
            let html = '<span class="emoji-reaction-display">';
            topEmojis.forEach(([emoji, count]) => {
                html += `<span class="emoji">${emoji}</span><span class="count">${formatNumber(count)}</span>`;
            });
            html += '</span>';
            return html;
        }

        let lastClickTime = 0;
        let clickTimer;
        let longPressTimer;
        let currentNeonPost = null;

        function addPostEventListeners(postElement, postData) {
            const postId = postData.id;
            const likeButton = postElement.querySelector('.like-button');
            const postOptionsBtn = postElement.querySelector('.post-options .fa-ellipsis-v');
            const optionsDropdown = postElement.querySelector('.options-dropdown');
            const reportBtn = postElement.querySelector('.report-btn');
            const deleteBtn = postElement.querySelector('.delete-btn');
            const copyLinkBtn = postElement.querySelector('.copy-link-btn');
            const remixBtn = postElement.querySelector('.remix-btn');
            const translateBtn = postElement.querySelector('.translate-button');
            const speakBtn = postElement.querySelector('.speak-button');
            const profileAvatar = postElement.querySelector('.profile-avatar');
            const usernameSpan = postElement.querySelector('.username');
            const emojiPicker = postElement.querySelector('.emoji-picker');
            const postContentP = postElement.querySelector('.post-content p[data-original-content]'); // Only select if post has original content

            if (profileAvatar) {
                profileAvatar.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openUserProfile(postData.userId);
                });
            }
            if (usernameSpan) {
                usernameSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openUserProfile(postData.userId);
                });
            }

            postElement.addEventListener('click', (e) => {
                if (e.target.closest('.like-button') || e.target.closest('.post-options') || e.target.closest('.translate-button') || e.target.closest('.speak-button') || e.target.closest('.emoji-picker') || e.target.closest('.profile-avatar') || e.target.closest('.username') || e.target.closest('a')) {
                    return; // Prevent triggering double click on interactive elements or links.
                }

                const currentTime = new Date().getTime();
                const timeDiff = currentTime - lastClickTime;

                if (timeDiff < 300 && timeDiff > 0) { // Double click detected (within 300ms)
                    clearTimeout(clickTimer);
                    handleLike(postId, postElement);
                    lastClickTime = 0;
                } else { // Single click (will delay to check for double click)
                    clearTimeout(clickTimer);
                    clickTimer = setTimeout(() => {
                        handleNeonEffect(postElement);
                    }, 300);
                }
                lastClickTime = currentTime;
            });

            // Long press for emoji reactions (mobile)
            postElement.addEventListener('touchstart', (e) => {
                // Ensure touch is not on other interactive elements
                if (e.target.closest('.like-button') || e.target.closest('.post-options') || e.target.closest('.translate-button') || e.target.closest('.speak-button') || e.target.closest('a') || e.target.closest('.profile-avatar') || e.target.closest('.username')) {
                    return;
                }
                e.preventDefault(); // Prevent default browser actions like context menu
                clearTimeout(clickTimer); // Clear any pending single click timeout
                longPressTimer = setTimeout(() => {
                    emojiPicker.classList.remove('hidden'); // Show emoji picker on long press
                }, 800); // 800ms for long press
            }, { passive: false }); // Use passive: false to allow preventDefault to work

            postElement.addEventListener('touchend', () => {
                clearTimeout(longPressTimer); // Clear long press timer if finger lifted
            });

            // Context menu event (for desktop right-click or other systems if supported)
            postElement.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent default browser context menu
                emojiPicker.classList.remove('hidden'); // Show emoji picker
            });

            // Hide emoji picker if clicked outside of post or emoji picker itself
            document.addEventListener('click', (e) => {
                if (emojiPicker && !emojiPicker.contains(e.target) && !postElement.contains(e.target)) {
                    emojiPicker.classList.add('hidden');
                }
            });

            // Emoji options click handling
            emojiPicker.querySelectorAll('.emoji-option').forEach(emojiOption => {
                emojiOption.addEventListener('click', async (e) => {
                    const selectedEmoji = e.target.dataset.emoji;
                    await handleEmojiReaction(postId, selectedEmoji, postElement);
                    emojiPicker.classList.add('hidden');
                });
            });

            // Post actions (like, report, etc.)
            if (likeButton) {
                likeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Stop propagation to prevent post's double-click or long-press.
                    handleLike(postId, postElement);
                });
            }

            if (postOptionsBtn) {
                postOptionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Stop propagation for the button.
                    optionsDropdown.classList.toggle('hidden'); // Toggle dropdown visibility.
                });
                document.addEventListener('click', (e) => { // Hide dropdown if click outside.
                    if (optionsDropdown && !postOptionsBtn.contains(e.target) && !optionsDropdown.contains(e.target)) {
                        optionsDropdown.classList.add('hidden');
                    }
                });
            }

            if (reportBtn) {
                reportBtn.addEventListener('click', () => {
                    handleReportPost(postId);
                    optionsDropdown.classList.add('hidden');
                });
            }

            if (copyLinkBtn) {
                copyLinkBtn.addEventListener('click', () => {
                    handleCopyPostLink(postId);
                    optionsDropdown.classList.add('hidden');
                });
            }

            if (remixBtn) {
                remixBtn.addEventListener('click', (e) => {
                    const originalPostId = e.target.dataset.originalPostId;
                    const originalContent = e.target.dataset.originalContent;
                    handleRemixPost(originalPostElement, originalPostId, originalContent); // Pass postElement directly.
                    optionsDropdown.classList.add('hidden');
                });
            }

            if (changeLangBtn) {
                changeLangBtn.addEventListener('click', () => {
                    showLanguageSelectModal(); // Show modal to select language
                    optionsDropdown.classList.add('hidden');
                });
            }

            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => {
                    handleDeletePost(postId, postElement);
                    optionsDropdown.classList.add('hidden');
                });
            }

            if (translateBtn) {
                translateBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent propagation.
                    if (postContentP) { // Check if original content is available.
                        handleTranslatePost(postContentP, userSelectedTranslationLanguage);
                    } else {
                        showToast("Content for translation not found.", 'error');
                    }
                });
            }
            if (speakBtn) {
                speakBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent propagation.
                    const postText = postContentP ? postContentP.textContent : ''; // Get current text.
                    if (postText) {
                        handleSpeakPost(postText, speakBtn);
                    } else {
                        showToast("No content to speak.", 'error');
                    }
                });
            }

            incrementViewCount(postId); // Increment view count for the post.
        }

        function handleNeonEffect(postElement) {
            // Remove neon from previously highlighted post, if any
            if (currentNeonPost && currentNeonPost !== postElement) {
                currentNeonPost.classList.remove('neon-glow');
            }
            postElement.classList.add('neon-glow'); // Apply neon to current post
            currentNeonPost = postElement;

            // Remove neon after a duration
            setTimeout(() => {
                if (postElement) { // Check if element still exists (e.g. not deleted while animated)
                    postElement.classList.remove('neon-glow');
                    if (currentNeonPost === postElement) {
                        currentNeonPost = null;
                    }
                }
            }, 3500); // 3.5 seconds
        }

        async function handleLike(postId, postElement) {
            if (!currentUser) {
                showToast("Please log in to like posts.", 'info');
                return;
            }

            const likeButtonIcon = postElement.querySelector('.like-button i');
            const likeCountSpan = postElement.querySelector('.like-button .like-count');

            try {
                const postRef = db.collection('posts').doc(postId);
                const postDoc = await postRef.get();
                if (!postDoc.exists) {
                    showToast("Post not found.", 'error');
                    return;
                }

                const postData = postDoc.data();
                const likedBy = postData.likedBy || []; // Array of UIDs who liked

                let newLikes = postData.likes || 0;
                let action = '';

                if (likedBy.includes(currentUser.uid)) {
                    // User already liked, so unlike
                    newLikes = Math.max(0, newLikes - 1); // Ensure likes don't go below zero
                    likeButtonIcon.classList.remove('fas', 'fa-heart'); // Solid heart
                    likeButtonIcon.classList.add('far', 'fa-heart');    // Outline heart
                    action = 'remove';
                } else {
                    // User hasn't liked, so like
                    newLikes++;
                    likeButtonIcon.classList.remove('far', 'fa-heart');
                    likeButtonIcon.classList.add('fas', 'fa-heart');
                    action = 'add';
                }

                await db.runTransaction(async (transaction) => {
                    const updatedLikedBy = action === 'add'
                        ? firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                        : firebase.firestore.FieldValue.arrayRemove(currentUser.uid);

                    transaction.update(postRef, {
                        likes: newLikes,
                        likedBy: updatedLikedBy // Atomically update array without reading entire document
                    });
                });

                likeCountSpan.textContent = formatNumber(newLikes); // Update UI
                showToast(action === 'add' ? "Post liked!" : "Post unliked.", 'success');

            } catch (error) {
                console.error("Error liking post:", error);
                showToast("Failed to like/unlike post. Please try again.", 'error');
            }
        }

        async function handleEmojiReaction(postId, emoji, postElement) {
            if (!currentUser) {
                showToast("Please log in to react to posts.", 'info');
                return;
            }

            try {
                const postRef = db.collection('posts').doc(postId);
                const postDoc = await postRef.get();
                if (!postDoc.exists) {
                    showToast("Post not found.", 'error');
                    return;
                }

                const postData = postDoc.data();
                const currentReactions = postData.reactions || {}; // Map of emoji: count
                const userReactions = postData.userReactions || {}; // Map of userId: emoji_reacted_with

                const existingReaction = userReactions[currentUser.uid]; // Get what current user previously reacted with

                await db.runTransaction(async (transaction) => {
                    let updatedUserReactions = { ...userReactions }; // Clone for modification
                    let updatedReactionsCount = { ...currentReactions }; // Clone for modification

                    if (existingReaction) {
                        // If user previously reacted, decrement count of the OLD emoji
                        updatedReactionsCount[existingReaction] = (updatedReactionsCount[existingReaction] || 1) - 1;
                        if (updatedReactionsCount[existingReaction] <= 0) {
                            delete updatedReactionsCount[existingReaction]; // Remove if count hits zero or less
                        }
                    }

                    if (existingReaction === emoji) {
                        // User clicked the SAME emoji again: implies "un-react"
                        delete updatedUserReactions[currentUser.uid]; // Remove user's specific reaction
                    } else {
                        // New reaction, or changing from one emoji to another
                        updatedReactionsCount[emoji] = (updatedReactionsCount[emoji] || 0) + 1; // Increment count for NEW emoji
                        updatedUserReactions[currentUser.uid] = emoji; // Update user's reaction
                    }

                    transaction.update(postRef, {
                        reactions: updatedReactionsCount, // Update aggregate emoji counts
                        userReactions: updatedUserReactions // Update user-specific reaction
                    });
                });

                // Update UI elements based on the final state from Firestore after transaction.
                const updatedPostDoc = await postRef.get();
                const updatedPostData = updatedPostDoc.data();

                const emojiReactionDisplayElement = postElement.querySelector('.emoji-reaction-display');
                const totalReactionsElement = postElement.querySelector('.total-reactions');
                
                emojiReactionDisplayElement.innerHTML = renderEmojiReactions(updatedPostData.reactions);
                totalReactionsElement.textContent = `${formatNumber(Object.values(updatedPostData.reactions || {}).reduce((a, b) => a + b, 0))} reactions`;

                showToast("Emoji reaction sent!", 'success');

            } catch (error) {
                console.error("Error sending emoji reaction:", error);
                showToast("Failed to send reaction. Please try again.", 'error');
            }
        }

        async function incrementViewCount(postId) {
            if (!currentUser) return; // Only track views for logged-in users.

            // The post-card element's presence and its IntersectionObserver would have initiated this.
            // Check session storage to ensure it's a unique view for this session.
            const sessionViewKey = `viewed_${postId}_${currentUser.uid}_session`;
            if (sessionStorage.getItem(sessionViewKey)) {
                return; // Already counted for this session, exit.
            }
            sessionStorage.setItem(sessionViewKey, 'true'); // Mark as viewed for current session.

            const viewsRef = db.collection('postViews').doc(postId);
            const postRef = db.collection('posts').doc(postId);
            const viewCountSpan = document.querySelector(`.post-card[data-post-id="${postId}"] .view-count-num`);

            try {
                await db.runTransaction(async (transaction) => {
                    const viewsDoc = await transaction.get(viewsRef);
                    let viewsData = viewsDoc.exists ? viewsDoc.data() : { totalViews: 0, viewedBy: {} };
                    const viewedBy = viewsData.viewedBy || {};

                    // Use a persistent key to ensure user doesn't generate unlimited views for one post
                    // This is for unique historical view tracking. You can clear this key for daily/hourly unique views if needed.
                    const userHistoricalViewKey = currentUser.uid;

                    if (!viewedBy[userHistoricalViewKey]) { // Only if this specific user hasn't historically viewed this post.
                        viewsData.totalViews = (viewsData.totalViews || 0) + 1; // Increment total views.
                        viewedBy[userHistoricalViewKey] = true; // Mark this user's historical view as true.

                        // Atomically update the postViews document.
                        transaction.set(viewsRef, {
                            totalViews: viewsData.totalViews,
                            viewedBy: viewedBy // Merge into sub-map
                        }, { merge: true });

                        // Also increment the view count on the main post document for easy display.
                        transaction.update(postRef, {
                            views: firebase.firestore.FieldValue.increment(1)
                        });

                        // Award Mint currency (since each view can award Mint now)
                        const postOwnerId = (await transaction.get(postRef)).data().userId; // Get post owner
                        const postOwnerRef = db.collection('users').doc(postOwnerId);
                        transaction.update(postOwnerRef, {
                            mint: firebase.firestore.FieldValue.increment(0.01) // Example: 0.01 Mint per unique view
                        });
                        
                        showToast(`+0.01 Mint for this view!`, 'success', 1500);

                        if (viewCountSpan) { // Optimistically update UI if element found.
                            viewCountSpan.textContent = formatNumber(viewsData.totalViews);
                        }
                    } else {
                        // User already viewed this post historically. No further view count increment.
                        console.log(`User ${currentUser.uid} already viewed post ${postId} historically.`);
                    }
                });
            } catch (error) {
                console.error("Error incrementing view count:", error);
                showToast("Failed to increment view count.", 'error');
            }
        }

        refreshPostsBtn.addEventListener('click', () => {
            postsFeed.innerHTML = '';
            lastVisiblePost = null;
            loadPosts();
            showToast("Feed refreshed!", 'info');
        });

        mainContent.addEventListener('scroll', () => {
            if (mainContent.scrollTop + mainContent.clientHeight >= mainContent.scrollHeight - 100 &&
                document.getElementById('home-screen').classList.contains('active')) {
                loadPosts();
            }
        });


        // --- Post Upload Functionality ---
        publishPostBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showToast("Please log in to upload posts.", 'error');
                return;
            }

            const content = postContentInput.value.trim();
            const boostHours = parseInt(postBoostSelect.value); // Selected boost hours
            const remixOriginalPostId = sessionStorage.getItem('remixOriginalPostId');
            const remixOriginalContent = sessionStorage.getItem('remixOriginalContent');

            if (!content) {
                showToast("Please enter some content for your post.", 'error');
                return;
            }
            if (content.length < 60) { // Min character length
                showToast("Post content must be at least 60 characters long.", 'error');
                return;
            }
            if (content.length > 10000) { // Max character length
                showToast("Post content cannot exceed 10,000 characters.", 'error');
                return;
            }


            const userDocRef = db.collection('users').doc(currentUser.uid);
            const userDoc = await userDocRef.get();
            const userData = userDoc.data();

            const currentLimit = userData.postLimit || 0;
            const currentCoins = userData.coins || 0;
            const requiredLimit = 1;

            let coinCost = 0; // Coins required based on boost hours
            switch(boostHours) {
                case 18: coinCost = 10; break;
                case 24: coinCost = 20; break;
                case 30: coinCost = 30; break;
                default: coinCost = 0; // Free 12 hours if 0 cost
            }

            if (currentLimit < requiredLimit) {
                showToast("You need 1 post limit to upload. Watch an ad to earn.", 'error', 5000);
                showAdModal('limit', { limit: 1 }); // Trigger ad modal to earn limits
                return;
            }

            if (currentCoins < coinCost) {
                showToast(`You need ${coinCost} Coins for ${boostHours} hours boost. You have ${formatNumber(currentCoins)} C. Watch an ad to earn.`, 'error', 5000);
                showAdModal('coins', { coins: coinCost - currentCoins }); // Trigger ad modal to earn coins
                return;
            }

            // Deduct resources immediately to prevent double spending
            try {
                await userDocRef.update({
                    postLimit: firebase.firestore.FieldValue.increment(-requiredLimit),
                    coins: firebase.firestore.FieldValue.increment(-coinCost)
                });
                showToast("Resources deducted successfully!", 'success');
            } catch (error) {
                console.error("Error deducting resources for post:", error);
                showToast("Failed to deduct resources for post. Please try again.", 'error');
                return;
            }

            uploadStatus.textContent = "Uploading post...";
            publishPostBtn.disabled = true; // Disable button during upload


            try {
                const imageUrl = ''; // Placeholder, as file upload is disabled
                const newPostRef = db.collection('posts').doc(); // Firestore will auto-generate ID for new post

                // Set post data, including remix details if applicable
                await newPostRef.set({
                    userId: currentUser.uid,
                    username: userData.username,
                    userProfileLogo: userData.profileLogo || getRandomLogoClass(), // User's selected logo
                    content: content,
                    imageUrl: imageUrl, // Will be empty string since disabled
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    likes: 0,
                    views: 0,
                    reactions: {}, // Map of emoji: count
                    userReactions: {}, // Map of userId: emoji
                    boostHours: boostHours,
                    expiryTime: firebase.firestore.Timestamp.fromMillis(Date.now() + (boostHours * 60 * 60 * 1000)), // Calculate expiry
                    isRemix: !!remixOriginalPostId, // Convert to boolean
                    remixOf: remixOriginalPostId || null,
                    remixOfContent: remixOriginalContent || null
                });

                // Increment user's total post count
                await userDocRef.update({
                    postCount: firebase.firestore.FieldValue.increment(1)
                });

                uploadStatus.textContent = "Post uploaded successfully!";
                showToast("Post uploaded successfully!", 'success');

                // Clear form fields and remix data from session storage
                postContentInput.value = '';
                postBoostSelect.value = '12';
                sessionStorage.removeItem('remixOriginalPostId');
                sessionStorage.removeItem('remixOriginalContent');

                // Navigate back to home feed and refresh posts
                showScreen('home-screen');
                postsFeed.innerHTML = ''; // Clear feed
                lastVisiblePost = null; // Reset pagination
                loadPosts(); // Load posts again to show new post

            } catch (error) {
                console.error("Error publishing post:", error);
                uploadStatus.textContent = `Error: ${error.message}`;
                showToast("Failed to upload post. Please try again.", 'error');
                // Refund resources if post upload failed after deduction (important for good UX)
                await userDocRef.update({
                    postLimit: firebase.firestore.FieldValue.increment(requiredLimit),
                    coins: firebase.firestore.FieldValue.increment(coinCost)
                });
                showToast("Resources refunded due to upload failure.", 'info');
            } finally {
                publishPostBtn.disabled = false; // Re-enable button
            }
        });

        // Ad Modal Logic - Simulate ad watching for rewards
        function showAdModal(purpose, details = {}) {
            currentAdPurpose = purpose;
            adRewardDetails = details;
            adModal.classList.remove('hidden');
            closeAdModalBtn.disabled = true; // Disable closing ad until it's "finished"

            const adPlaceholder = document.getElementById('ad-placeholder');
            adPlaceholder.innerHTML = '<p>Simulating Ad (5 seconds)...</p><div class="loader"></div>';
            
            setTimeout(() => {
                adPlaceholder.innerHTML = '<p>Ad Completed! Click "Close Ad" to claim your reward.</p>';
                closeAdModalBtn.disabled = false;
            }, 5000); // Simulate a 5-second ad duration
        }

        closeAdModalBtn.addEventListener('click', async () => {
            adModal.classList.add('hidden'); // Hide the ad modal
            await processAdReward(); // Process rewards
        });

        async function processAdReward() {
            if (!currentUser) return; // Must be logged in

            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                let rewardMessageText = "Reward Claimed: ";
                let updateData = {}; // Object to hold all Firestore updates

                // Every ad watch also gives Mint (for monetization tracking)
                updateData.mint = firebase.firestore.FieldValue.increment(1); 
                
                if (currentAdPurpose === 'coins') {
                    const coinsToAward = adRewardDetails.coins || 10;
                    updateData.coins = firebase.firestore.FieldValue.increment(coinsToAward);
                    rewardMessageText = `+${coinsToAward} Coins & +1 Mint`;
                } else if (currentAdPurpose === 'credits') {
                    const creditsToAward = adRewardDetails.credits || 5;
                    updateData.credits = firebase.firestore.FieldValue.increment(creditsToAward);
                    rewardMessageText = `+${creditsToAward} Credits & +1 Mint`;
                } else if (currentAdPurpose === 'limit') {
                    const limitsToAward = adRewardDetails.limit || 1;
                    updateData.postLimit = firebase.firestore.FieldValue.increment(limitsToAward);
                    rewardMessageText = `+${limitsToAward} Post Limit & +1 Mint`;
                } else if (currentAdPurpose === 'message-credit') { // Specific purpose, e.g. from chat failure
                    const creditsToAward = adRewardDetails.credits || 1;
                    updateData.credits = firebase.firestore.FieldValue.increment(creditsToAward);
                    rewardMessageText = `+${creditsToAward} Credits for Messaging & +1 Mint`;
                } else if (currentAdPurpose === 'daily-reward') {
                    // Daily reward gives a bundle of resources
                    updateData.coins = firebase.firestore.FieldValue.increment(DAILY_REWARD.coins);
                    updateData.credits = firebase.firestore.FieldValue.increment(DAILY_REWARD.credits);
                    updateData.postLimit = firebase.firestore.FieldValue.increment(DAILY_REWARD.limit);
                    updateData.lastRewardClaim = Date.now(); // Update last claim timestamp
                    // Mint already incremented by the +1 from general ad watch, but you could add more for daily
                    rewardMessageText = `You claimed your daily bundle!\n+${DAILY_REWARD.coins} C, +${DAILY_REWARD.credits} Cr, +${DAILY_REWARD.limit} L & +1 Mint!`;
                }

                if (Object.keys(updateData).length > 0) { // Only update if there are changes
                    await userDocRef.update(updateData);
                    showRewardPopup(rewardMessageText); // Show details in a popup
                    showToast("Reward successfully granted!", 'success');
                } else {
                    showToast("Ad viewed, no specific reward granted (debug/placeholder).", 'info');
                }

            } catch (error) {
                console.error("Error processing ad reward:", error);
                showToast("Failed to process ad reward. Please try again.", 'error');
            } finally {
                currentAdPurpose = ''; // Reset context
                adRewardDetails = {}; // Reset details
            }
        }

        // --- Daily Reward Logic ---
        const DAILY_REWARD_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
        const DAILY_REWARD = { limit: 2, coins: 10, credits: 10, mint: 5 }; // Define actual values

        async function checkDailyRewardStatus(lastClaimTimestamp) {
            if (!currentUser || !giftClaimBtn) return; // Ensure element exists

            const now = Date.now();
            const lastClaimTime = lastClaimTimestamp;

            if (now - lastClaimTime >= DAILY_REWARD_INTERVAL) {
                giftClaimBtn.classList.add('neon-glow'); // Visual cue for available reward
            } else {
                giftClaimBtn.classList.remove('neon-glow');
            }
        }

        // Event listener for daily reward button
        giftClaimBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showToast("Please log in to claim daily rewards.", 'info');
                return;
            }

            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const userDoc = await userDocRef.get();
                const userData = userDoc.data();
                const lastClaimTime = userData.lastRewardClaim || 0; // 0 if never claimed

                const now = Date.now();

                if (now - lastClaimTime >= DAILY_REWARD_INTERVAL) {
                    showAdModal('daily-reward', DAILY_REWARD); // Daily reward requires watching an ad (simulated)
                } else {
                    const timeRemaining = DAILY_REWARD_INTERVAL - (now - lastClaimTime);
                    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
                    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
                    showToast(`Next daily reward available in: ${hours}h ${minutes}m`, 'info', 5000);
                }
            } catch (error) {
                console.error("Error claiming daily reward:", error);
                showToast("Failed to claim reward. Please try again.", 'error');
            }
        });


        function showRewardPopup(message) {
            rewardMessage.textContent = message;
            rewardPopup.classList.remove('hidden');
        }

        closeRewardPopupBtn.addEventListener('click', () => {
            rewardPopup.classList.add('hidden');
        });

        // Withdraw Mint Modal
        withdrawCoinsBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showToast("Please log in to withdraw Mint.", 'info');
                return;
            }
            try {
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const currentMint = userDoc.data().mint || 0;
                currentMintBalance.textContent = `${formatNumber(currentMint)} M`; // Display current balance

                if (currentMint < 1000) { // Check withdrawal threshold
                    showToast(`You need at least 1,000 Mint to withdraw. You have ${formatNumber(currentMint)} M.`, 'error', 5000);
                    return;
                }
                withdrawModal.classList.remove('hidden'); // Show the withdrawal modal
            } catch (error) {
                console.error("Error checking mint balance for withdrawal:", error);
                showToast("Could not retrieve Mint balance for withdrawal.", 'error');
            }
        });

        closeWithdrawModalBtn.addEventListener('click', () => {
            withdrawModal.classList.add('hidden');
        });

        confirmWithdrawBtn.addEventListener('click', async () => {
            if (!currentUser) return; // User must be logged in.

            const paypalEmail = withdrawPaypalEmail.value.trim();
            const realName = withdrawRealName.value.trim();
            const age = parseInt(withdrawAge.value.trim());
            const dob = withdrawDob.value.trim();

            if (!paypalEmail || !realName || isNaN(age) || !dob) {
                showToast("Please fill all withdrawal details: PayPal Email, Full Name, Age, and Date of Birth.", 'error', 5000);
                return;
            }
            if (age < 13) {
                showToast("You must be at least 13 years old to withdraw funds.", 'error');
                return;
            }

            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const userDoc = await userDocRef.get();
                const userData = userDoc.data();
                const currentMint = userData.mint || 0;

                if (currentMint < 1000) { // Re-check threshold before processing.
                    showToast(`You need at least 1,000 Mint to withdraw. You have ${formatNumber(currentMint)} M.`, 'error', 5000);
                    return;
                }

                showToast("Processing withdrawal request...", 'info', 5000);
                
                // Set Mint balance to 0 after request (simulate backend processing).
                await userDocRef.update({
                    mint: 0
                });

                // In a real app, this would involve sending withdrawal details to a secure backend 
                // (e.g., Firebase Cloud Function) which then interfaces with a payment gateway.
                // The backend would send the email to apknixy@gmail.com and handle real funds transfer.
                // For this demo, we just log and show success.
                showToast("Withdrawal request submitted! Please check your email for confirmation within 1-15 business days.", 'success', 8000);
                console.log("Simulated Withdrawal Details Sent (for demo):", {
                    userId: currentUser.uid,
                    username: userData.username,
                    userEmail: currentUser.email,
                    amountMint: currentMint,
                    paypalEmail: paypalEmail,
                    realName: realName,
                    age: age,
                    dob: dob,
                    timestamp: new Date().toISOString()
                });

                withdrawModal.classList.add('hidden'); // Close modal
                withdrawPaypalEmail.value = ''; // Clear fields
                withdrawRealName.value = '';
                withdrawAge.value = '';
                withdrawDob.value = '';

            } catch (error) {
                console.error("Error initiating withdrawal:", error);
                showToast("Failed to submit withdrawal request. Please try again.", 'error');
            }
        });


        // --- Profile Management ---
        async function loadUserProfile(userId) {
            if (!userId) {
                showToast("User ID is missing to load profile.", 'error');
                return;
            }
            currentProfileViewingId = userId; // Set the user whose profile is currently being displayed.

            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    updateProfileDisplay(userData); // Update UI elements on profile page.
                    loadProfilePosts(userId); // Load posts associated with this profile.

                    // Adjust button visibility based on whether it's the current user's profile or another user's.
                    if (userId === currentUser.uid) { // If it's the owner's profile.
                        editProfileBtn.classList.remove('hidden');
                        followUserBtn.classList.add('hidden');
                        unfollowUserBtn.classList.add('hidden');
                        messageUserBtn.classList.add('hidden');
                        profileWhatsappLink.classList.add('hidden');
                        profileInstagramLink.classList.add('hidden');
                        // Update tab titles for "My Posts" and "My Reposts" if they are present.
                        const myPostsTab = document.querySelector('.profile-post-tabs button[data-tab="posts"]');
                        const myRepostsTab = document.querySelector('.profile-post-tabs button[data-tab="reposts"]');
                        if (myPostsTab) myPostsTab.textContent = 'My Posts';
                        if (myRepostsTab) myRepostsTab.textContent = 'My Reposts';
                    } else { // If viewing another user's profile.
                        editProfileBtn.classList.add('hidden');
                        messageUserBtn.classList.remove('hidden'); // Enable messaging button.

                        // Check current user's following status towards the viewed user.
                        const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
                        const currentUserData = currentUserDoc.data();
                        if (currentUserData.following && currentUserData.following.includes(userId)) {
                            followUserBtn.classList.add('hidden'); // Hide follow button.
                            unfollowUserBtn.classList.remove('hidden'); // Show unfollow button.
                        } else {
                            followUserBtn.classList.remove('hidden');
                            unfollowUserBtn.classList.add('hidden');
                        }

                        // Display social links if available.
                        if (userData.whatsapp) {
                            profileWhatsappLink.classList.remove('hidden');
                            profileWhatsappLink.href = `https://wa.me/${userData.whatsapp.replace(/\D/g, '')}`;
                        } else { profileWhatsappLink.classList.add('hidden'); profileWhatsappLink.removeAttribute('href'); }
                        if (userData.instagram) {
                            profileInstagramLink.classList.remove('hidden');
                            profileInstagramLink.href = `https://www.instagram.com/${userData.instagram}`;
                        } else { profileInstagramLink.classList.add('hidden'); profileInstagramLink.removeAttribute('href'); }
                        
                        // Update tab titles to reflect other user's name.
                        const postsTab = document.querySelector('.profile-post-tabs button[data-tab="posts"]');
                        const repostsTab = document.querySelector('.profile-post-tabs button[data-tab="reposts"]');
                        if (postsTab) postsTab.textContent = `@${userData.username}'s Posts`;
                        if (repostsTab) repostsTab.textContent = `@${userData.username}'s Reposts`;

                        // Handle private profiles for non-followers.
                        if (userData.isPrivate && !(currentUserData.following && currentUserData.following.includes(userId))) {
                            profilePostsFeed.innerHTML = '<p style="text-align: center; color: #ccc;">This account is private. Follow to view posts.</p>';
                            profileRepostsFeed.innerHTML = ''; // Hide reposts if private
                            if (postsTab) postsTab.classList.add('hidden'); // Hide post tabs if private
                            if (repostsTab) repostsTab.classList.add('hidden');
                        } else {
                            // Show tabs for public profiles or followed private profiles
                            if (postsTab) postsTab.classList.remove('hidden');
                            if (repostsTab) repostsTab.classList.remove('hidden');
                        }
                    }
                } else {
                    showToast("User profile not found.", 'error');
                    // If trying to view a non-existent profile, redirect back home.
                    if (userId !== currentUser.uid) { showScreen('home-screen'); }
                }
            } catch (error) {
                console.error("Error loading user profile:", error);
                showToast("Error loading profile. Please try again.", 'error');
            }
        }

        // Update displayed profile details using fetched userData.
        function updateProfileDisplay(userData) {
            const isCurrentUserProfile = currentUser && userData.uid === currentUser.uid;

            myProfileUsername.textContent = `@${userData.username || 'NewUser'}`;
            myProfileName.textContent = userData.name || ''; // Display name
            myProfileBio.textContent = userData.bio || ''; // Bio text
            currentProfileUsernamePosts.textContent = userData.username || 'Me';

            // Set profile avatar (direct image URL takes precedence over emoji logo).
            if (userData.profilePicUrl) {
                myProfileAvatar.style.backgroundImage = `url('${userData.profilePicUrl}')`;
                myProfileAvatar.className = 'profile-avatar-large'; // Use class without emoji background.
            } else {
                myProfileAvatar.style.backgroundImage = 'none'; // Clear any old background image.
                myProfileAvatar.className = `profile-avatar-large ${getLogoCssClass(userData.profileLogo || 'logo-1')}`;
            }

            myPostsCount.textContent = formatNumber(userData.postCount || 0);
            myFollowersCount.textContent = formatNumber(userData.followersCount || 0);
            myFollowingCount.textContent = formatNumber(userData.followingCount || 0);

            // Populate Edit Profile Modal fields if it's the current user's profile.
            if (isCurrentUserProfile) {
                editUsernameInput.value = userData.username || '';
                editNameInput.value = userData.name || '';
                editBioInput.value = userData.bio || '';
                editWhatsappInput.value = userData.whatsapp || '';
                editInstagramInput.value = userData.instagram || '';
                profilePicUrlInput.value = userData.profilePicUrl || '';
                accountPrivacyToggle.checked = userData.isPrivate || false;
                accountPrivacyStatus.textContent = userData.isPrivate ? 'Private' : 'Public';
                populateProfileLogoOptions(userData.profileLogo, userData.profilePicUrl);
            }
        }

        // Load posts for the currently displayed profile.
        async function loadProfilePosts(userId) {
            profilePostsFeed.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show loading spinner.
            try {
                const querySnapshot = await db.collection('posts')
                    .where('userId', '==', userId)
                    .where('expiryTime', '>', firebase.firestore.Timestamp.now()) // Only show active posts.
                    .orderBy('timestamp', 'desc')
                    .limit(10) // Limit the number of posts displayed.
                    .get();

                profilePostsFeed.innerHTML = ''; // Clear loader and previous posts.

                if (querySnapshot.empty) {
                    profilePostsFeed.innerHTML = '<p style="text-align: center; color: #ccc;">No posts yet.</p>';
                    return;
                }

                querySnapshot.docs.forEach(doc => {
                    renderPost({ id: doc.id, ...doc.data() }, profilePostsFeed); // Render each post.
                });
            } catch (error) {
                console.error("Error loading profile posts:", error);
                showToast("Error loading posts.", 'error');
                profilePostsFeed.innerHTML = '<p style="text-align: center; color: red;">Error loading posts.</p>';
            }
        }

        // Load reposts for the currently displayed profile.
        async function loadProfileReposts(userId) {
            profileRepostsFeed.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show loading spinner.
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                const repostedPostIds = userDoc.data().reposts || [];

                profileRepostsFeed.innerHTML = ''; // Clear loader.

                if (repostedPostIds.length === 0) {
                    profileRepostsFeed.innerHTML = '<p style="text-align: center; color: #ccc;">No reposts yet.</p>';
                    return;
                }

                // Fetch up to 10 reposted posts. Firestore 'in' query limit is 10.
                const postPromises = repostedPostIds.slice(0, 10).map(id => db.collection('posts').doc(id).get());
                const postResults = await Promise.all(postPromises); // Use Promise.all to fetch all concurrently.

                let hasActiveReposts = false;
                postResults.forEach(result => {
                    // Check if fetch was successful and post exists and is not expired.
                    if (result.exists && result.data().expiryTime && result.data().expiryTime.toMillis() > Date.now()) {
                        renderPost({ id: result.id, ...result.data() }, profileRepostsFeed);
                        hasActiveReposts = true;
                    }
                });

                if (!hasActiveReposts) {
                    profileRepostsFeed.innerHTML = '<p style="text-align: center; color: #ccc;">No active reposts.</p>';
                }

            } catch (error) {
                console.error("Error loading profile reposts:", error);
                showToast("Error loading reposts.", 'error');
                profileRepostsFeed.innerHTML = '<p style="text-align: center; color: red;">Error loading reposts.</p>';
            }
        }

        // Event listeners for Profile tabs (My Posts/My Reposts)
        document.querySelectorAll('.profile-post-tabs .tab-btn').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.profile-post-tabs .tab-btn').forEach(t => t.classList.remove('active'));
                e.currentTarget.classList.add('active'); // Set active class for selected tab.

                const tabType = e.currentTarget.dataset.tab;
                // Show/hide corresponding feeds.
                if (tabType === 'posts') {
                    profilePostsFeed.classList.remove('hidden');
                    profileRepostsFeed.classList.add('hidden');
                    loadProfilePosts(currentProfileViewingId); // Reload posts for this tab.
                } else if (tabType === 'reposts') {
                    profilePostsFeed.classList.add('hidden');
                    profileRepostsFeed.classList.remove('hidden');
                    loadProfileReposts(currentProfileViewingId); // Reload reposts for this tab.
                }
            });
        });

        // Edit Profile Modal Buttons
        editProfileBtn.addEventListener('click', () => {
            editProfileModal.classList.remove('hidden'); // Show modal.
            profileModalInstruction.textContent = "Edit your profile details:"; // Clear instruction if not first-time setup.
            updateAuthStatus(saveProfileStatus, '', 'hidden'); // Clear status messages on open.
        });

        cancelEditProfileBtn.addEventListener('click', () => {
            editProfileModal.classList.add('hidden'); // Hide modal.
        });

        // Username Availability Check
        let usernameCheckTimeout;
        editUsernameInput.addEventListener('input', async () => {
            clearTimeout(usernameCheckTimeout); // Clear previous check to debounce.
            usernameAvailability.textContent = ''; // Clear status display.
            usernameAvailability.className = '';

            const newUsername = editUsernameInput.value.trim();
            if (newUsername === '') {
                usernameAvailability.textContent = 'Username cannot be empty.';
                usernameAvailability.classList.add('error-text');
                return;
            }

            // Get current username for comparison (from fetched user data)
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const currentUsername = userDoc.data().username;

            if (newUsername.toLowerCase() === (currentUsername ? currentUsername.toLowerCase() : '')) {
                usernameAvailability.textContent = 'Username is available.';
                usernameAvailability.classList.add('success-text');
                return;
            }
            if (newUsername.includes(" ") || newUsername.includes("@") || newUsername.includes("#") || newUsername.length < 3) { // More stringent checks.
                usernameAvailability.textContent = "Username must be 3-30 characters, no spaces, no special characters (@, # etc.).";
                usernameAvailability.classList.add('error-text');
                return;
            }


            usernameCheckTimeout = setTimeout(async () => {
                try {
                    const usersRef = db.collection('users');
                    // Query Firestore for existing usernames (case-insensitive search helper)
                    const snapshot = await usersRef.where('username_lowercase', '==', newUsername.toLowerCase()).get();

                    if (snapshot.empty) {
                        usernameAvailability.textContent = 'Username is available.';
                        usernameAvailability.classList.add('success-text');
                    } else {
                        usernameAvailability.textContent = 'Username already taken.';
                        usernameAvailability.classList.add('error-text');
                    }
                } catch (error) {
                    console.error("Error checking username availability:", error);
                    usernameAvailability.textContent = 'Error checking username.';
                    usernameAvailability.classList.add('error-text');
                }
            }, 500); // Debounce to reduce Firestore reads
        });

        // Toggle Account Privacy status display
        accountPrivacyToggle.addEventListener('change', () => {
            accountPrivacyStatus.textContent = accountPrivacyToggle.checked ? 'Private' : 'Public';
        });

        // Populate Profile Logo Options and handle direct URL vs. emoji selection.
        function populateProfileLogoOptions(currentLogoClass, currentProfilePicUrl) {
            profileLogoOptions.innerHTML = ''; // Clear previous options.

            // Add option for direct URL pic if it's currently set for the user.
            if (currentProfilePicUrl) {
                const directUrlOptionDiv = document.createElement('div');
                directUrlOptionDiv.className = `logo-option-item selected`;
                directUrlOptionDiv.style.backgroundImage = `url('${currentProfilePicUrl}')`;
                directUrlOptionDiv.dataset.type = 'url';
                directUrlOptionDiv.dataset.value = currentProfilePicUrl;
                profileLogoOptions.appendChild(directUrlOptionDiv);
            }

            // Add all predefined emoji logo options.
            PROFILE_LOGOS.forEach(logo => {
                const logoItem = document.createElement('div');
                logoItem.className = `logo-option-item user-${logo.class}`; // Apply CSS class.
                logoItem.dataset.type = 'emoji'; // Custom data attribute for type.
                logoItem.dataset.value = logo.class; // Custom data attribute for value.
                
                // Add default content for emojis via span (for browsers not supporting ::before).
                logoItem.innerHTML = `<span style="font-size: 24px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #1a1a2e;">${logo.emoji}</span>`;

                // Select the emoji if it matches the currentLogoClass AND no direct URL pic is active.
                if (!currentProfilePicUrl && currentLogoClass === logo.class) {
                    logoItem.classList.add('selected');
                }
                
                logoItem.addEventListener('click', () => {
                    profileLogoOptions.querySelectorAll('.logo-option-item').forEach(item => item.classList.remove('selected')); // Deselect all others.
                    profilePicUrlInput.value = ''; // Clear direct URL input if an emoji is selected.
                    logoItem.classList.add('selected'); // Select current emoji.
                });
                profileLogoOptions.appendChild(logoItem);
            });

            // If user types into the direct URL field, deselect all other emoji options.
            profilePicUrlInput.addEventListener('input', () => {
                if (profilePicUrlInput.value.trim() !== '') {
                    profileLogoOptions.querySelectorAll('.logo-option-item').forEach(item => item.classList.remove('selected'));
                }
            });
        }

        // Save Profile Changes
        saveProfileBtn.addEventListener('click', async () => {
            updateAuthStatus(saveProfileStatus, '', 'hidden'); // Clear previous save status.

            if (!currentUser) {
                showToast("Error: No authenticated user. Please log in.", 'error');
                return;
            }

            const newUsername = editUsernameInput.value.trim();
            const newName = editNameInput.value.trim();
            const newBio = editBioInput.value.trim();
            const newWhatsapp = editWhatsappInput.value.trim();
            const newInstagram = editInstagramInput.value.trim();
            const newProfilePicUrl = profilePicUrlInput.value.trim();

            let finalProfilePicUrl = newProfilePicUrl;
            let newProfileLogo = '';

            const selectedLogoElement = profileLogoOptions.querySelector('.logo-option-item.selected');

            // Determine final profile visual source (URL > Emoji)
            if (finalProfilePicUrl) {
                newProfileLogo = ""; 
            } else if (selectedLogoElement && selectedLogoElement.dataset.type === 'emoji') {
                finalProfilePicUrl = ""; 
                newProfileLogo = selectedLogoElement.dataset.value;
            } else { // Fallback if neither URL nor a specific emoji is chosen (or current user has no existing)
                newProfileLogo = 'logo-1'; 
                finalProfilePicUrl = "";
            }


            const isPrivate = accountPrivacyToggle.checked;

            if (newUsername === '') {
                updateAuthStatus(saveProfileStatus, "Username cannot be empty.", 'error');
                return;
            }
            if (!/^[a-zA-Z0-9_.]+$/.test(newUsername) || newUsername.length < 3 || newUsername.length > 30) {
                updateAuthStatus(saveProfileStatus, "Username must be 3-30 chars (alphanumeric, underscore, dot only).", 'error');
                return;
            }

            // Retrieve current user data for comparison, essential for partial updates.
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const userDoc = await userDocRef.get();
            const currentData = userDoc.data();
            
            // For new registrations/first-time profile setup, enforce Display Name (name) field.
            if ((currentData && (currentData.username === "" || currentData.name === "")) && newName.length < 1) { 
                updateAuthStatus(saveProfileStatus, "Display Name is required for initial profile setup.", 'error');
                return;
            }

            try {
                updateAuthStatus(saveProfileStatus, "Saving profile changes...", 'info');
                await userDocRef.update({
                    username: newUsername,
                    username_lowercase: newUsername.toLowerCase(), // For case-insensitive search.
                    name: newName,
                    bio: newBio,
                    whatsapp: newWhatsapp,
                    instagram: newInstagram,
                    profileLogo: newProfileLogo,
                    profilePicUrl: finalProfilePicUrl, 
                    isPrivate: isPrivate
                    // Other counters/values like followersCount etc., are managed by other specific operations (not direct here).
                });

                // Batch update user's existing posts with new username or profile picture, and privacy.
                // This ensures consistency across owned content.
                const postsSnapshot = await db.collection('posts').where('userId', '==', currentUser.uid).get();
                const batch = db.batch();
                postsSnapshot.docs.forEach(doc => {
                    const postRef = db.collection('posts').doc(doc.id);
                    batch.update(postRef, {
                        username: newUsername,
                        profilePicUrl: finalProfilePicUrl,
                        userProfileLogo: finalProfilePicUrl ? "" : newProfileLogo,
                        isPrivate: isPrivate // Propagate profile's privacy setting to user's posts
                    });
                });
                await batch.commit();
                console.log("Post metadata update batch committed.");

                editProfileModal.classList.add('hidden'); // Hide the modal on successful save.
                showToast("Profile updated successfully!", 'success');
                loadUserProfile(currentUser.uid); // Reload displayed profile data to reflect changes.
                console.log("Profile saved and modal hidden.");

            } catch (error) {
                console.error("Error saving profile:", error);
                updateAuthStatus(saveProfileStatus, `Failed to save profile. ${error.message || 'Unknown error'}.`, 'error');
            }
        });

        // Follow another user.
        followUserBtn.addEventListener('click', () => handleFollow(currentProfileViewingId));
        // Unfollow a user.
        unfollowUserBtn.addEventListener('click', () => handleUnfollow(currentProfileViewingId));

        async function handleFollow(targetUserId) {
            if (!currentUser) { showToast("Please log in to follow users.", 'info'); return; }
            if (currentUser.uid === targetUserId) { showToast("Cannot follow yourself.", 'info'); return; }

            try {
                const currentUserRef = db.collection('users').doc(currentUser.uid);
                const targetUserRef = db.collection('users').doc(targetUserId);

                const result = await db.runTransaction(async (transaction) => {
                    const currentUserDoc = await transaction.get(currentUserRef);
                    const targetUserDoc = await transaction.get(targetUserRef);

                    if (!currentUserDoc.exists || !targetUserDoc.exists) { throw new Error("User document not found."); }
                    const currentUserData = currentUserDoc.data();
                    const targetUserData = targetUserDoc.data();

                    if (currentUserData.following && currentUserData.following.includes(targetUserId)) { return { status: 'already-following' }; } // Already following.

                    // If target user is private, cannot follow directly.
                    if (targetUserData.isPrivate) { showToast("This account is private. Cannot follow directly.", 'info', 4000); throw new Error("Private account."); }

                    transaction.update(currentUserRef, { following: firebase.firestore.FieldValue.arrayUnion(targetUserId), followingCount: firebase.firestore.FieldValue.increment(1) });
                    transaction.update(targetUserRef, { followers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid), followersCount: firebase.firestore.FieldValue.increment(1) });
                    return { status: 'followed' };
                });

                if (result.status === 'followed') { showToast("Followed user!", 'success'); followUserBtn.classList.add('hidden'); unfollowUserBtn.classList.remove('hidden'); loadUserProfile(currentProfileViewingId); }
                else if (result.status === 'already-following') { showToast("Already following this user.", 'info'); }

            } catch (error) {
                console.error("Error following user:", error);
                if (error.message && error.message.includes("Private account")) {} else { showToast(`Failed to follow: ${error.message || 'Unknown error'}`, 'error'); }
            }
        }

        async function handleUnfollow(targetUserId) {
            if (!currentUser || currentUser.uid === targetUserId) { showToast("Cannot unfollow yourself or not logged in.", 'info'); return; }

            try {
                const currentUserRef = db.collection('users').doc(currentUser.uid);
                const targetUserRef = db.collection('users').doc(targetUserId);

                const result = await db.runTransaction(async (transaction) => {
                    const currentUserDoc = await transaction.get(currentUserRef);
                    
                    if (!currentUserDoc.exists) { throw new Error("Current user document not found."); }
                    const targetUserDoc = await transaction.get(targetUserRef); // Target user also needs to exist
                    if (!targetUserDoc.exists) { throw new Error("Target user document not found."); } // Error if target disappears

                    const currentUserData = currentUserDoc.data();
                    
                    if (!currentUserData.following || !currentUserData.following.includes(targetUserId)) { return { status: 'not-following' }; } // Not following.

                    transaction.update(currentUserRef, { following: firebase.firestore.FieldValue.arrayRemove(targetUserId), followingCount: firebase.firestore.FieldValue.increment(-1) });
                    transaction.update(targetUserRef, { followers: firebase.firestore.FieldValue.arrayRemove(currentUser.uid), followersCount: firebase.firestore.FieldValue.increment(-1) });
                    return { status: 'unfollowed' };
                });

                if (result.status === 'unfollowed') { showToast("Unfollowed user.", 'info'); followUserBtn.classList.remove('hidden'); unfollowUserBtn.classList.add('hidden'); loadUserProfile(currentProfileViewingId); }
                else if (result.status === 'not-following') { showToast("Not currently following this user.", 'info'); }

            } catch (error) {
                console.error("Error unfollowing user:", error);
                showToast(`Failed to unfollow: ${error.message || 'Unknown error'}`, 'error');
            }
        }

        // Remove a follower (only if you are the user being unfollowed)
        async function removeFollower(followerId) {
            if (!currentUser) { showToast("Please log in.", 'info'); return; }

            try {
                const currentUserRef = db.collection('users').doc(currentUser.uid);
                const followerUserRef = db.collection('users').doc(followerId);

                await db.runTransaction(async (transaction) => {
                    const currentUserDoc = await transaction.get(currentUserRef);
                    const followerUserDoc = await transaction.get(followerUserRef); // Fetch follower's doc to update their 'following' list
                    
                    if (!currentUserDoc.exists || !followerUserDoc.exists) { throw new Error("User document not found."); }

                    const currentUserData = currentUserDoc.data();
                    
                    if (!currentUserData.followers || !currentUserData.followers.includes(followerId)) { return { status: 'not-follower' }; } // Not a follower.

                    transaction.update(currentUserRef, { followers: firebase.firestore.FieldValue.arrayRemove(followerId), followersCount: firebase.firestore.FieldValue.increment(-1) });
                    transaction.update(followerUserRef, { following: firebase.firestore.FieldValue.arrayRemove(currentUser.uid), followingCount: firebase.firestore.FieldValue.increment(-1) }); // Update follower's following count too.
                    return { status: 'removed' };
                });

                showToast("Follower removed successfully.", 'success');
                if (document.getElementById('follow-list-modal').classList.contains('active') && followListTitle.textContent.includes('Followers')) {
                    showFollowList(currentUser.uid, 'followers');
                }
                loadUserProfile(currentUser.uid);

            } catch (error) {
                console.error("Error removing follower:", error);
                showToast(`Failed to remove follower: ${error.message || 'Unknown error'}`, 'error');
            }
        }

        // View Followers/Following Lists
        document.querySelectorAll('.clickable-stat').forEach(stat => {
            stat.addEventListener('click', (e) => {
                const statType = e.currentTarget.dataset.stat;
                const userId = currentProfileViewingId;
                if (userId && (statType === 'followers' || statType === 'following')) {
                    showFollowList(userId, statType);
                }
            });
        });

        async function showFollowList(userId, type) {
            if (!currentUser) return; // Should already be logged in at this point, but safety.
            followListContent.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>';
            followListTitle.textContent = type === 'followers' ? 'Followers' : 'Following';
            followListModal.classList.remove('hidden');

            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (!userDoc.exists) { followListContent.innerHTML = '<p style="text-align: center;">User not found.</p>'; return; }

                const userRefs = userDoc.data()[type] || [];
                if (userRefs.length === 0) { followListContent.innerHTML = `<p style="text-align: center;">No ${type} found.</p>`; return; }

                const usersData = [];
                const userPromises = userRefs.map(uid => db.collection('users').doc(uid).get()); // Fetch each user's data
                const userDocs = await Promise.all(userPromises);

                userDocs.forEach(doc => {
                    if (doc.exists) { usersData.push({ id: doc.id, ...doc.data() }); }
                });
                usersData.sort((a, b) => (a.username || '').localeCompare(b.username || '')); // Sort by username.

                followListContent.innerHTML = '';
                const currentUserFollowingList = (await db.collection('users').doc(currentUser.uid).get()).data().following || [];

                usersData.forEach(user => {
                    const userItem = document.createElement('li');
                    userItem.className = 'search-user-item';
                    userItem.dataset.userId = user.id;

                    const userLogoClass = getLogoCssClass(user.profileLogo || getRandomLogoClass());
                    const avatarHtml = `<div class="profile-avatar small ${userLogoClass}" ${user.profilePicUrl ? `style="background-image: url('${user.profilePicUrl}');"` : ''}></div>`;

                    let actionBtnHtml = '';
                    if (currentUser && currentUser.uid !== user.id) { // Not current user
                        const isFollowing = currentUserFollowingList.includes(user.id);
                        const btnClass = isFollowing ? 'secondary-btn' : 'primary-btn';
                        const btnText = isFollowing ? 'Following' : 'Follow';
                        actionBtnHtml = `<button class="btn small ${btnClass} follow-btn" data-target-id="${user.id}">${btnText}</button>`;
                    } else if (currentUser && currentUser.uid === userId && type === 'followers') { // On *my* followers list
                        actionBtnHtml = `<button class="btn small danger-btn remove-follower-btn" data-target-id="${user.id}">Remove</button>`;
                    }


                    userItem.innerHTML = `
                        ${avatarHtml}
                        <span class="search-username">@${user.username}</span>
                        ${actionBtnHtml}
                    `;
                    followListContent.appendChild(userItem);

                    const actionBtn = userItem.querySelector('button');
                    if (actionBtn) {
                        actionBtn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            const targetId = e.target.dataset.targetId;
                            if (actionBtn.classList.contains('follow-btn')) {
                                if (e.target.textContent === 'Follow') {
                                    await handleFollow(targetId);
                                    e.target.textContent = 'Following';
                                    e.target.classList.replace('primary-btn', 'secondary-btn');
                                } else {
                                    await handleUnfollow(targetId);
                                    e.target.textContent = 'Follow';
                                    e.target.classList.replace('secondary-btn', 'primary-btn');
                                }
                            } else if (actionBtn.classList.contains('remove-follower-btn')) {
                                await removeFollower(targetId);
                            }
                        });
                    }

                    userItem.addEventListener('click', () => { // Open profile on click of list item
                        followListModal.classList.add('hidden');
                        openUserProfile(user.id);
                    });
                });
            } catch (error) {
                console.error("Error loading follow list:", error);
                showToast("Error loading follow list.", 'error');
                followListContent.innerHTML = '<p style="text-align: center; color: red;">Error loading list.</p>';
            }
        }

        closeFollowListModalBtn.addEventListener('click', () => {
            followListModal.classList.add('hidden');
        });

        // Open a user's profile screen
        function openUserProfile(userId) {
            if (currentUser && userId === currentUser.uid) { // If user clicks their own profile.
                showScreen('profile-screen');
                loadUserProfile(currentUser.uid);
            } else { // If user clicks another user's profile.
                showScreen('profile-screen');
                loadUserProfile(userId);
            }
        }


        // --- Messaging ---
        messageUserBtn.addEventListener('click', () => {
            if (!currentUser) { showToast("Please log in to message.", 'info'); return; }
            if (!currentProfileViewingId) { showToast("No user selected to message.", 'error'); return; }
            openChatWindow(currentChatPartnerId); // Use current profile as default chat partner
        });

        async function loadRecentChats() {
            if (!currentUser) return;
            recentChatsList.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>';

            try {
                // Clear any existing chat listeners to prevent duplicates.
                if (unsubscribeFromChat) {
                    unsubscribeFromChat();
                    unsubscribeFromChat = null;
                }
                
                // Real-time listener for current user's chats
                db.collection('messages')
                    .where('participants', 'array-contains', currentUser.uid)
                    .orderBy('timestamp', 'desc') // To get latest messages
                    .onSnapshot(async (snapshot) => {
                        const chatsOverview = {}; // Maps partnerId to {lastMessage, timestamp, isSender}
                        
                        snapshot.docs.forEach(doc => {
                            const data = doc.data();
                            const partnerId = data.senderId === currentUser.uid ? data.receiverId : data.senderId;

                            // Keep only the *absolute latest* message for each distinct partner.
                            if (!chatsOverview[partnerId] || data.timestamp.toMillis() > chatsOverview[partnerId].timestamp) {
                                chatsOverview[partnerId] = {
                                    partnerId: partnerId,
                                    lastMessage: data.content,
                                    timestamp: data.timestamp.toMillis(),
                                    isSender: data.senderId === currentUser.uid
                                };
                            }
                        });

                        // Sort all unique chat partners by their latest message timestamp.
                        const sortedChatPartners = Object.values(chatsOverview).sort((a, b) => b.timestamp - a.timestamp);

                        recentChatsList.innerHTML = ''; // Clear previous display
                        if (sortedChatPartners.length === 0) {
                            recentChatsList.innerHTML = '<p style="text-align: center; color: #ccc;">No recent chats. Start a conversation!</p>';
                            return;
                        }

                        // Fetch detailed user info for each partner for display.
                        for (const chatSummary of sortedChatPartners) {
                            const partnerDoc = await db.collection('users').doc(chatSummary.partnerId).get();
                            if (partnerDoc.exists) {
                                const partnerData = partnerDoc.data();
                                const chatItem = document.createElement('li');
                                chatItem.className = 'chat-item';
                                chatItem.dataset.userId = partnerData.uid;

                                const partnerLogoClass = getLogoCssClass(partnerData.profileLogo || getRandomLogoClass());
                                const avatarHtml = `<div class="profile-avatar small ${partnerLogoClass}" ${partnerData.profilePicUrl ? `style="background-image: url('${partnerData.profilePicUrl}');"` : ''}></div>`;

                                chatItem.innerHTML = `
                                    ${avatarHtml}
                                    <div class="chat-info">
                                        <span class="chat-username">@${partnerData.username}</span>
                                        <span class="last-message">${chatSummary.isSender ? 'You: ' : ''}${chatSummary.lastMessage}</span>
                                    </div>
                                `;
                                chatItem.addEventListener('click', () => openChatWindow(partnerData.uid));
                                recentChatsList.appendChild(chatItem);
                            }
                        }
                    }, error => {
                        console.error("Error setting up recent chats listener:", error);
                        showToast("Error loading recent chats.", 'error');
                        recentChatsList.innerHTML = '<p style="text-align: center; color: red;">Error loading chats.</p>';
                    });

            } catch (error) {
                console.error("Error initializing chat list:", error);
                showToast("Failed to load chats overview. Please try again.", 'error');
            }
        }


        async function openChatWindow(partnerId) {
            if (!currentUser) { showToast("Please log in to chat.", 'info'); return; }
            currentChatPartnerId = partnerId; // Set current chat partner.
            
            // Manage UI visibility.
            messageListContainer.classList.add('hidden'); 
            chatWindowContainer.classList.remove('hidden');
            chatMessages.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; 

            // Detach any existing chat listener to prevent conflicts if switching chats.
            if (unsubscribeFromChat) {
                unsubscribeFromChat();
                unsubscribeFromChat = null;
            }

            try {
                const partnerDoc = await db.collection('users').doc(partnerId).get();
                if (partnerDoc.exists) {
                    chatPartnerUsername.textContent = `@${partnerDoc.data().username}`; // Display partner's username.
                    const partnerLogoClass = getLogoCssClass(partnerDoc.data().profileLogo || getRandomLogoClass());
                    const partnerAvatar = chatWindowContainer.querySelector('.profile-avatar.small');
                    partnerAvatar.className = `profile-avatar small ${partnerLogoClass}`; // Set partner's avatar.
                    if (partnerDoc.data().profilePicUrl) {
                        partnerAvatar.style.backgroundImage = `url('${partnerDoc.data().profilePicUrl}')`;
                    } else {
                        partnerAvatar.style.backgroundImage = 'none';
                    }
                } else {
                    chatPartnerUsername.textContent = "@UnknownUser";
                    const partnerAvatar = chatWindowContainer.querySelector('.profile-avatar.small');
                    partnerAvatar.className = `profile-avatar small user-logo-default`; // Default fallback avatar.
                    partnerAvatar.style.backgroundImage = 'none';
                }

                // Create a sorted participants array for consistent Firestore querying.
                const participantsArray = [currentUser.uid, partnerId].sort();

                // Set up real-time listener for messages between these two participants.
                unsubscribeFromChat = db.collection('messages')
                    .where('participants', '==', participantsArray) // Query messages between these exact two users.
                    .orderBy('timestamp', 'asc') // Display messages in chronological order.
                    .limit(100) // Limit the number of messages fetched for performance.
                    .onSnapshot(snapshot => {
                        chatMessages.innerHTML = ''; // Clear previous messages in UI.
                        snapshot.docs.forEach(doc => {
                            const message = doc.data();
                            // Ensure message is not expired client-side (Firebase Rules handles server-side expiration).
                            const isWithin12Hours = (Date.now() - message.timestamp.toMillis()) < (12 * 60 * 60 * 1000);
                            if (isWithin12Hours) { // Only display active messages.
                                const messageBubble = document.createElement('div');
                                messageBubble.className = `message-bubble ${message.senderId === currentUser.uid ? 'right' : 'left'}`; // Right for sender, left for receiver.
                                messageBubble.textContent = message.content;
                                chatMessages.appendChild(messageBubble);
                            }
                        });
                        chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll to the bottom of the chat.
                    }, error => {
                        console.error("Error getting messages in real-time:", error);
                        chatMessages.innerHTML = '<p style="text-align: center; color: red;">Error loading messages.</p>';
                        showToast("Error loading messages.", 'error');
                    });

                // Attach event listeners for emoji picker (if enabled for chat input).
                const emojiPickerChat = chatWindowContainer.querySelector('.emoji-picker-chat');
                if (emojiPickerChat) {
                    messageInput.addEventListener('touchstart', (e) => {
                        clearTimeout(longPressTimer);
                        longPressTimer = setTimeout(() => { emojiPickerChat.classList.remove('hidden'); }, 800);
                    }, { passive: true }); // Prevent default scroll for responsiveness.
                    messageInput.addEventListener('touchend', () => { clearTimeout(longPressTimer); });
                    messageInput.addEventListener('contextmenu', (e) => { e.preventDefault(); emojiPickerChat.classList.remove('hidden'); });

                    document.addEventListener('click', (e) => {
                        if (emojiPickerChat && !emojiPickerChat.contains(e.target) && !messageInput.contains(e.target)) {
                            emojiPickerChat.classList.add('hidden');
                        }
                    });

                    emojiPickerChat.querySelectorAll('.emoji-option').forEach(emojiOption => {
                        emojiOption.addEventListener('click', (e) => {
                            messageInput.value += ` ${e.target.dataset.emoji} `;
                            emojiPickerChat.classList.add('hidden');
                            messageInput.focus();
                        });
                    });
                }
            } catch (error) {
                console.error("Error opening chat window:", error);
                showToast("Failed to open chat. Please try again.", 'error');
            }
        }

        // Back button in chat window returns to recent chats list.
        backToChatsBtn.addEventListener('click', () => {
            messageListContainer.classList.remove('hidden');
            chatWindowContainer.classList.add('hidden');
            currentChatPartnerId = null;
            if (unsubscribeFromChat) { // Detach Firestore listener when chat window is closed.
                unsubscribeFromChat();
                unsubscribeFromChat = null;
            }
        });

        // Send message functionality in chat.
        sendMessageBtn.addEventListener('click', async () => {
            if (!currentUser || !currentChatPartnerId) { showToast("You must be logged in and have a chat partner.", 'error'); return; }
            const messageContent = messageInput.value.trim();
            if (messageContent === '') { showToast("Message cannot be empty.", 'info'); return; }

            const userDocRef = db.collection('users').doc(currentUser.uid);
            const userDoc = await userDocRef.get();
            const userData = userDoc.data();
            const currentCredits = userData.credits || 0; // Check current credits.

            if (currentCredits < 1) { // 1 credit per message.
                showToast("You need 1 Credit to send a message. Watch an ad to earn more!", 'error', 5000);
                showAdModal('message-credit', { credits: 1 }); // Trigger ad modal.
                return;
            }

            try {
                // Deduct credits for sending message.
                await userDocRef.update({ credits: firebase.firestore.FieldValue.increment(-1) });
                
                const participantsArray = [currentUser.uid, currentChatPartnerId].sort(); // Consistent participants array.
                
                await db.collection('messages').add({
                    senderId: currentUser.uid,
                    receiverId: currentChatPartnerId,
                    content: messageContent,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    participants: participantsArray,
                    read: false // Message starts as unread.
                });

                messageInput.value = ''; // Clear input field.
                chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom of chat.
                showToast("Message sent!", 'success');
            } catch (error) {
                console.error("Error sending message:", error);
                showToast("Failed to send message. Please try again.", 'error');
                // Refund credits if sending fails.
                await userDocRef.update({ credits: firebase.firestore.FieldValue.increment(1) });
            }
        });


        // --- Search Functionality ---
        searchBtn.addEventListener('click', () => performSearch());
        searchQueryInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { performSearch(); } });

        async function performSearch() {
            const query = searchQueryInput.value.trim().toLowerCase();
            searchUserList.innerHTML = '';
            searchPostList.innerHTML = '';
            noSearchResults.classList.add('hidden');

            if (query === '') { showToast("Please enter a search query.", 'info'); return; }

            let foundResults = false;

            try {
                // Search for users by lowercase username.
                const userSnapshot = await db.collection('users')
                    .where('username_lowercase', '>=', query)
                    .where('username_lowercase', '<=', query + '\uf8ff')
                    .limit(10)
                    .get();

                if (!userSnapshot.empty) {
                    foundResults = true;
                    // Prepare data for follow button logic outside the loop.
                    const currentUserFollowingList = currentUser ? (await db.collection('users').doc(currentUser.uid).get()).data().following || [] : [];

                    userSnapshot.docs.forEach(doc => {
                        const userData = { id: doc.id, ...doc.data() };
                        const userItem = document.createElement('li');
                        userItem.className = 'search-user-item';
                        userItem.dataset.userId = userData.id;

                        const userLogoClass = getLogoCssClass(userData.profileLogo || getRandomLogoClass());
                        const avatarHtml = `<div class="profile-avatar small ${userLogoClass}" ${userData.profilePicUrl ? `style="background-image: url('${userData.profilePicUrl}');"` : ''}></div>`;

                        let followBtnHtml = '';
                        if (currentUser && currentUser.uid !== userData.id) { // Button visible only if not own profile.
                            const isFollowing = currentUserFollowingList.includes(userData.id);
                            const btnClass = isFollowing ? 'secondary-btn' : 'primary-btn';
                            const btnText = isFollowing ? 'Following' : 'Follow';
                            followBtnHtml = `<button class="btn small ${btnClass} follow-btn" data-target-id="${userData.id}">${btnText}</button>`;
                        }

                        userItem.innerHTML = `
                            ${avatarHtml}
                            <span class="search-username">@${userData.username}</span>
                            ${followBtnHtml}
                        `;
                        searchUserList.appendChild(userItem);

                        const followBtn = userItem.querySelector('.follow-btn');
                        if (followBtn) {
                            followBtn.addEventListener('click', async (e) => {
                                e.stopPropagation();
                                const targetId = e.target.dataset.targetId;
                                if (e.target.textContent === 'Follow') {
                                    await handleFollow(targetId);
                                    e.target.textContent = 'Following';
                                    e.target.classList.replace('primary-btn', 'secondary-btn');
                                } else {
                                    await handleUnfollow(targetId);
                                    e.target.textContent = 'Follow';
                                    e.target.classList.replace('secondary-btn', 'primary-btn');
                                }
                                loadUserProfile(currentUser.uid); // Refresh follower counts on current user's profile if on screen.
                            });
                        }
                        userItem.addEventListener('click', () => openUserProfile(userData.id)); // Click on item to view profile.
                    });
                }
            } catch (error) {
                console.error("Error searching users:", error);
                showToast("Error searching users. Check console.", 'error');
            }

            try {
                // Basic text search on post content (limited performance for large datasets).
                const postSnapshot = await db.collection('posts')
                    .where('expiryTime', '>', firebase.firestore.Timestamp.now())
                    .orderBy('expiryTime', 'desc') // To sort recent active posts first
                    .limit(50) // Fetch more to check content client-side
                    .get();

                postSnapshot.docs.forEach(doc => {
                    const postData = { id: doc.id, ...doc.data() };
                    // Perform client-side case-insensitive content search.
                    if (postData.content && postData.content.toLowerCase().includes(query)) {
                        foundResults = true;
                        renderPost(postData, searchPostList);
                    }
                });
            } catch (error) {
                console.error("Error searching posts:", error);
                showToast("Error searching posts. Check console.", 'error');
            }

            if (!foundResults) {
                noSearchResults.classList.remove('hidden'); // Show "No results" message if nothing found.
            }
        }


        // --- Post Options (Report/Delete/Copy Link/Remix) ---
        async function handleReportPost(postId) {
            if (!currentUser) { showToast("Please log in to report posts.", 'info'); return; }
            try {
                await db.collection('reports').add({
                    postId: postId,
                    reportedBy: currentUser.uid,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    status: 'pending' // Default status.
                });
                showToast("Post reported successfully. We will review it.", 'info');
            } catch (error) {
                console.error("Error reporting post:", error);
                showToast("Failed to report post. Try again.", 'error');
            }
        }

        async function handleCopyPostLink(postId) {
            // Placeholder: Construct actual sharable link to the post.
            const shareableLink = `${window.location.origin}/post/${postId}`; // Example link.
            try {
                await navigator.clipboard.writeText(shareableLink); // Use Clipboard API.
                showToast("Post link copied to clipboard!", 'success');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showToast("Failed to copy link to clipboard. Please try manually.", 'error');
            }
        }

        // Activate Remix mode for a post.
        function handleRemixPost(originalPostElement, originalPostId, originalContent) {
            if (!currentUser) { showToast("Please log in to remix posts.", 'info'); return; }

            // Add visual feedback to the original post element (shake/highlight).
            originalPostElement.classList.add('remixed');
            originalPostElement.style.animation = 'shake 0.5s'; 

            showToast("Remix mode activated! Your next post will be a remix of this content.", 'info', 4000);

            showScreen('upload-screen'); // Navigate to the upload screen.
            postContentInput.value = `"${originalContent}" (Remix of post ID: ${originalPostId})\n\nMy remix: `; // Pre-fill content.
            
            // Store original post ID and content in session storage for upload logic.
            sessionStorage.setItem('remixOriginalPostId', originalPostId);
            sessionStorage.setItem('remixOriginalContent', originalContent);

            uploadScreen.scrollTop = 0; // Scroll to top of upload screen.

            // Remove animation class after it completes.
            originalPostElement.addEventListener('animationend', () => {
                originalPostElement.style.animation = ''; // Clear animation
            }, { once: true }); // Listener fires only once.
        }

        // Delete post (only for owner or admin)
        async function handleDeletePost(postId, postElement) {
            if (!currentUser) { showToast("Please log in to delete posts.", 'info'); return; }

            try {
                const postRef = db.collection('posts').doc(postId);
                const postDoc = await postRef.get();

                if (postDoc.exists && postDoc.data().userId === currentUser.uid) { // Ensure user is the owner.
                    if (confirm("Are you sure you want to delete this post? This action cannot be undone.")) {
                        // Perform deletion as a Firestore transaction to ensure related data is also handled.
                        await db.runTransaction(async (transaction) => {
                            transaction.delete(postRef); // Delete main post document.

                            // Delete associated comments (better handled by Cloud Functions for scalability).
                            const commentsSnapshot = await db.collection('comments').where('postId', '==', postId).get();
                            commentsSnapshot.docs.forEach(commentDoc => { transaction.delete(db.collection('comments').doc(commentDoc.id)); });

                            // Delete associated postViews document.
                            const postViewsRef = db.collection('postViews').doc(postId);
                            if ((await transaction.get(postViewsRef)).exists) { transaction.delete(postViewsRef); }

                            // Decrement owner's total post count.
                            const userRef = db.collection('users').doc(currentUser.uid);
                            transaction.update(userRef, { postCount: firebase.firestore.FieldValue.increment(-1) });
                        });

                        postElement.remove(); // Remove the post from the UI.
                        showToast("Post deleted successfully.", 'success');
                    }
                } else {
                    showToast("You can only delete your own posts.", 'error');
                }
            } catch (error) {
                console.error("Error deleting post:", error);
                showToast("Failed to delete post. Please try again.", 'error');
            }
        }

        // --- Translate Post Feature (Simulated) ---
        function showLanguageSelectModal() {
            languageOptionsContainer.innerHTML = '';
            // Define available languages with their codes and simulated translation texts.
            const languages = [
                { code: 'en', name: 'English', simText: 'This is a simulated English translation.' },
                { code: 'hi', name: 'हिन्दी (Hindi)', simText: 'यह एक सिमुलेटेड हिंदी अनुवाद है!' },
                { code: 'es', name: 'Español (Spanish)', simText: '¡Esta es una traducción simulada al español!' },
                { code: 'fr', name: 'Français (French)', simText: 'Ceci est une traduction française simulée !' },
                { code: 'de', name: 'Deutsch (German)', simText: 'Dies ist eine simulierte deutsche Übersetzung!' },
                { code: 'ja', name: '日本語 (Japanese)', simText: 'これはシミュレートされた日本語の翻訳です！' }
            ];

            // Dynamically create language options in the modal.
            languages.forEach(lang => {
                const option = document.createElement('div');
                option.className = 'language-option';
                option.textContent = lang.name;
                option.dataset.lang = lang.code; // Store language code in data attribute.
                option.dataset.simText = lang.simText; // Store simulated text.
                if (lang.code === userSelectedTranslationLanguage) { // Mark current selection.
                    option.classList.add('selected');
                }
                option.addEventListener('click', () => { // Handle click to select.
                    languageOptionsContainer.querySelectorAll('.language-option').forEach(item => item.classList.remove('selected'));
                    option.classList.add('selected');
                });
                languageOptionsContainer.appendChild(option);
            });

            languageSelectModal.classList.remove('hidden'); // Show the modal.
        }

        saveLanguageBtn.addEventListener('click', () => {
            const selectedOption = languageOptionsContainer.querySelector('.language-option.selected');
            if (selectedOption) {
                userSelectedTranslationLanguage = selectedOption.dataset.lang; // Update global language preference.
                showToast(`Translation language set to ${selectedOption.textContent}`, 'success');
            }
            languageSelectModal.classList.add('hidden'); // Hide modal.
        });

        cancelLanguageBtn.addEventListener('click', () => {
            languageSelectModal.classList.add('hidden'); // Hide modal.
        });

        // Predefined simulated translations for demonstration purposes.
        const simulatedTranslations = {
            'en': 'This is a simulated English translation.',
            'hi': 'यह एक सिमुलेटेड हिंदी अनुवाद है!',
            'es': '¡Esta es una traducción simulada al español!',
            'fr': 'Ceci est une traduction française simulée !',
            'de': 'Dies ist eine simulierte deutsche Übersetzung!' ,
            'ja': 'これはシミュレートされた日本語の翻訳です！'
        };

        function handleTranslatePost(postContentPElement, targetLang) {
            const originalContent = postContentPElement.dataset.originalContent; // Get original content from data attribute.
            const currentText = postContentPElement.textContent;

            // Toggle between original and simulated translated text.
            if (currentText === originalContent || currentText === (simulatedTranslations[userSelectedTranslationLanguage] || simulatedTranslations['en'])) {
                const simulatedTranslatedText = simulatedTranslations[targetLang] || simulatedTranslations['en'];
                postContentPElement.textContent = simulatedTranslatedText;
                showToast(`Simulating translation to ${targetLang.toUpperCase()}...`, 'info');
            } else {
                postContentPElement.textContent = originalContent; // Revert to original.
                showToast("Reverting to original text...", 'info');
            }
            showToast("Note: Actual translation requires a backend API integration.", 'info', 5000);
        }

        // --- Speak Post (Text-to-Speech) Feature ---
        function handleSpeakPost(textToSpeak, speakButtonElement) {
            if (!('speechSynthesis' in window)) { // Check for browser compatibility.
                showToast("Your device does not support text-to-speech.", 'error');
                return;
            }

            // Stop any ongoing speech if there is any.
            if (currentSpeaker && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel(); // Cancel current speech.
                document.querySelectorAll('.speak-button').forEach(btn => {
                    btn.classList.remove('active'); // Remove highlight from any active speaker.
                    btn.dataset.speaking = 'false';
                });
                if (speakButtonElement.dataset.speaking === 'true') { // If it was *this* button speaking, just toggle off.
                    currentSpeaker = null;
                    showToast("Speech stopped.", 'info');
                    return;
                }
            }

            const utterance = new SpeechSynthesisUtterance(textToSpeak); // Create new utterance.
            utterance.rate = 1; 
            utterance.pitch = 1;

            // Try to set voice based on selected language.
            const voices = window.speechSynthesis.getVoices();
            const targetVoice = voices.find(voice => voice.lang.startsWith(userSelectedTranslationLanguage)) ||
                               voices.find(voice => voice.lang.startsWith('en')) ||
                               voices[0]; // Fallback to English or first available.
            if (targetVoice) { utterance.voice = targetVoice; }

            // Event listeners for speech start/end/error to update UI.
            utterance.onstart = () => {
                currentSpeaker = utterance;
                speakButtonElement.classList.add('active'); // Highlight speaker button.
                speakButtonElement.dataset.speaking = 'true';
                showToast("Speaking post...", 'info');
            };

            utterance.onend = () => {
                speakButtonElement.classList.remove('active'); // De-highlight speaker button.
                speakButtonElement.dataset.speaking = 'false';
                if (currentSpeaker === utterance) { currentSpeaker = null; } // Clear current speaker.
                showToast("Speech ended.", 'info');
            };

            utterance.onerror = (event) => {
                console.error('SpeechSynthesisUtterance.onerror', event);
                speakButtonElement.classList.remove('active');
                speakButtonElement.dataset.speaking = 'false';
                if (currentSpeaker === utterance) { currentSpeaker = null; }
                showToast("Error speaking post.", 'error');
            };

            window.speechSynthesis.speak(utterance); // Start speaking.
        }

        // --- Initial Load Control (Executed once DOM is ready) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired. Starting initial app display.");
            
            // 1. Initially ensure app and auth containers are hidden using CSS '.hidden' class.
            appContainer.classList.add('hidden'); 
            authContainer.classList.add('hidden'); 

            // 2. Make the diagnostic 'load-status' message visible immediately.
            // This is your very first visible feedback if JavaScript is running.
            if (loadStatusElement) {
                loadStatusElement.textContent = "Loading Application...";
                loadStatusElement.style.display = 'block'; 
                console.log("Diagnostic: 'load-status' message is now visible. JavaScript is running.");
            } else {
                console.warn("Diagnostic: 'load-status' element not found. Please ensure it's in HTML.");
            }

            // 3. Set a brief timeout before starting the authentication flow.
            // This gives the browser a small moment to render basic CSS and HTML content properly.
            setTimeout(() => {
                console.log("Initial rendering buffer passed (100ms). Initiating Firebase authentication check.");
                // Kick off the authentication flow. `onAuthStateChanged` listener will then call `checkUserAndRedirect`.
            }, 100); 

            // 4. Set a fallback timeout for `onAuthStateChanged`.
            // In case Firebase SDK fails or is slow to initialize and report user state (rare, but possible),
            // this ensures the UI still progresses after a fixed time (e.g., 3 seconds).
            // This prevents the app from being stuck indefinitely on a blank screen if Firebase SDK gets stuck.
            setTimeout(() => {
                if (!hasRunInitialAuthCheck) { 
                    console.warn("Fallback: Authentication state check forced due to primary delay. UI should now proceed.");
                    checkUserAndRedirect(auth.currentUser); // Force check again.
                }
            }, 3000); // Max 3 seconds to get the main UI loaded.
        });
    </script>
</body>
</html>
